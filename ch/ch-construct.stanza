defpackage chipper.construct :
   import core
   import verse
   import chipper.ir

;========== Namespaces =================
val MODULE-NAMES = HashTable<Symbol,True>(symbol-hash)
defn gen-module-name (name:Symbol) :
   if key?(MODULE-NAMES, name) : gensym(to-string(name))
   else :
      MODULE-NAMES[name] = true
      name

var SCOPE-NAMES: HashTable<Symbol,True> = HashTable<Symbol,True>(symbol-hash)
defn gen-scope-name (name:Symbol) :
   if key?(SCOPE-NAMES, name) : gensym(to-string(name))
   else :
      SCOPE-NAMES[name] = true
      name
defn in-new-scope<?T> (f: () -> ?T) :
   val prev-scope = SCOPE-NAMES
   dynamic-wind(
      fn () : SCOPE-NAMES = HashTable<Symbol,True>(symbol-hash)
      f
      fn (f) : SCOPE-NAMES = prev-scope)

;========== Command List ===============
val COMMAND-LIST = Vector<Command>()

defn push-command (c:Command) :
   add(COMMAND-LIST, c)
   
defn collect-commands (f: () -> ?) :
   val commands = Vector<Command>()
   val prev-commands = COMMAND-LIST
   dynamic-wind(
      fn () : COMMAND-LIST = commands
      f
      fn (f) : COMMAND-LIST = prev-commands)

   ;Group commands
   val n = length(commands)
   switch {n == _} :
      0 : EmptyCommand()
      1 : commands[0]
      else : Begin(to-list(commands))


;========== Module List ================
val MODULE-LIST = Vector<Module>()

public defn make-module (name:Symbol, ports: Streamable<Port>, f: () -> ?) :
   val name* = gen-module-name(name)
   val body = in-new-scope(collect-commands{f})
   add(MODULE-LIST, Module(name*, to-list(ports), body))
   name*

public defn make-instance (name:Symbol, module:Symbol) :
   val name* = gen-scope-name(name)
   push-command(DefInstance(name*, Ref(module)))
   Ref(name*)

public definterface ModuleBuilder<T>
public defmulti handle<?T> (m:ModuleBuilder<?T>, name:Symbol) -> T

;========= Conditions ==================
public defn conditionally (pred: Handle, conseq: () -> ?, alt: () -> ?) :
   val conseq-body = collect-commands(conseq)
   val alt-body = collect-commands(alt)
   push-command(Conditionally(immediate(pred), conseq-body, alt-body))

;========== Circuit ====================
public defn make-circuit (f: () -> ?) :
   clear(MODULE-NAMES)
   clear(MODULE-LIST)
   clear(COMMAND-LIST)
   f()
   val top-module = module(last-command) where :
      val last-command = COMMAND-LIST[length(COMMAND-LIST) - 1] as DefInstance
   Circuit(to-list(MODULE-LIST), name(top-module as Ref))   

;=========== Wires =====================
public defn make-wire<?T> (name:Symbol, builder:HBuilder<?T>, value:False|Handle) -> T :
   val wire-name = gen-scope-name(name)
   push-command(DefWire(wire-name, type(builder)))
   push-command(Connect(Ref(wire-name), immediate(value as Handle))) when value != false
   handle(builder, Ref(wire-name))

;============ Registers ================
public defn make-register<?T> (name:Symbol, builder:HBuilder<?T>, value:False|Handle) -> RegHandle<T> :
   val reg-name = gen-scope-name(name)
   push-command(DefRegister(reg-name, type(builder)))
   push-command(Connect(Ref(reg-name), immediate(value as Handle))) when value != false
   RegHandle<T>(Ref(reg-name), builder)

;============ Vecs =====================
public defclass Vec<T>
public defmulti get<?T> (v:Vec<?T>, i:Int) -> T
public defmulti get<?T> (v:Vec<?T>, h:IntT|RegHandle<IntT>) -> T

public defn Vec<?T> (vec-name:Symbol, builder:HBuilder<?T>, vec-args: Streamable<T>) :
   ;Convert to array
   val args = to-array(vec-args)

   ;Create vector command
   val vec-name* = gen-scope-name(vec-name)
   val args* = map(immediate, to-list(args) as List)
   push-command(DefVector(vec-name*, type(builder), args*))   
   
   new Vec<T> :
      defmethod get (this, i:Int) :
         args[i]
      defmethod get (this, idx:IntT|RegHandle<IntT>) :
         val name = gen-scope-name('n)
         val idx-imm = immediate(unwrap-register<IntT>(idx))
         push-command(DefAccessor(name, Ref(vec-name*), UNKNOWN-DIR, idx-imm))
         handle(builder, Ref(name))

public defn Vec<?T> (vec-name:Symbol, n:Int, builder:HBuilder<?T>, f: () -> T) :
   Vec(vec-name, builder, stream(f{}, 0 to n))

;=========== Builders ==================
public definterface HBuilder<T>
public defmulti handle<?T> (b:HBuilder<?T>, ref:Immediate) -> T
public defmulti type (b:HBuilder) -> Type

;=========== Handles ===================
public definterface Handle
public defmulti immediate (h:Handle) -> Immediate

public defn connect-handles (h1:Handle, h2:Handle) :
   push-command(Connect(immediate(h1), immediate(h2)))

;========== Register Handles ===========
public defstruct RegHandle<T> <: Handle :
   ref: Immediate
   data-builder: HBuilder<T>

public defn init<?T> (r:RegHandle<?T>) :
   handle(data-builder(r), Field(ref(r), 'init))

public defn register-data<?T> (r:RegHandle<?T>) :
   handle(data-builder(r), Field(ref(r), 'data))

public defn unwrap-register<T> (r:RegHandle<T>|T) -> T :
   match(r) :
      (r:RegHandle<T>) : register-data(r)
      (r:T) : r

;========== Int Handles ================
public defclass IntT <: Handle
public defclass IntTBuilder <: HBuilder<IntT>

public defn connect (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   match(h1, h2) :
      (h1:IntT, h2:IntT) : connect-handles(h1, h2)
      (h1, h2) : connect(unwrap-register<IntT>(h1), unwrap-register<IntT>(h2))

public defn IntT (width:Width) :
   new IntTBuilder :
      defmethod handle (this, ref:Immediate) :
         new IntT :
            defmethod immediate (this) : ref
      defmethod type (this) :
         UIntType(width)

public defn IntT (width:Int) :
   IntT(IntWidth(width))

public defn IntT () :
   IntT(UnknownWidth())

;=========== Int Operators =============
defn do-op (op:PrimOp, h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   val name = gen-scope-name('n)
   val args = list(immediate(unwrap-register<IntT>(h1)),
                   immediate(unwrap-register<IntT>(h2)))
   push-command(DoPrim(name, op, args, List()))
   handle(IntT(), Ref(name))

public defn plus (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(ADD-OP, h1, h2)
public defn add-mod (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(ADD-MOD-OP, h1, h2)
public defn sub-mod (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(SUB-MOD-OP, h1, h2)
public defn minus (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(MINUS-OP, h1, h2)
public defn times (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(TIMES-OP, h1, h2)
public defn divide (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(DIVIDE-OP, h1, h2)
public defn modulo (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(MOD-OP, h1, h2)
public defn shift-left (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(SHIFT-LEFT-OP, h1, h2)
public defn shift-right (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(SHIFT-RIGHT-OP, h1, h2)
public defn bit-and (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(BIT-AND-OP, h1, h2)
public defn bit-or (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(BIT-OR-OP, h1, h2)
public defn bit-xor (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(BIT-XOR-OP, h1, h2)
public defn bit-concat (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(CONCAT-OP, h1, h2)
public defn less? (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(LESS-OP, h1, h2)
public defn less-eq? (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(LESS-EQ-OP, h1, h2)
public defn greater? (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(GREATER-OP, h1, h2)
public defn greater-eq? (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(GREATER-EQ-OP, h1, h2)
public defn bit-equal? (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(EQUAL-OP, h1, h2)
public defn get (h1:IntT|RegHandle<IntT>, h2:IntT|RegHandle<IntT>) :
   do-op(BIT-SELECT-OP, h1, h2)
public defn get (h1:IntT|RegHandle<IntT>, i:Int) :
   do-op(BIT-SELECT-OP, h1, CInt(i))

;========= Constructors ================
public defn CInt (value:Int, width:Width) :
   val name = gen-scope-name('n)
   push-command(DefUInt(name, value, width))
   handle(IntT(), Ref(name))
   
public defn CInt (value:Int, width:Int) :
   CInt(value, IntWidth(width))

public defn CInt (value:Int) :
   CInt(value, UnknownWidth())
