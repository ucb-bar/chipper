defpackage chipper.ir :
   import core
   import verse
   import stanza.lexer

;========= Mjolnir Direction ===========
public definterface Direction
public val INPUT = new Direction
public val OUTPUT = new Direction
public val UNKNOWN-DIR = new Direction

public defn flip (d:Direction) :
   switch {d == _} :
      INPUT : OUTPUT
      OUTPUT : INPUT
      UNKNOWN-DIR : UNKNOWN-DIR

public defn times (x:Direction, y:Direction) :
   if x == INPUT : flip(y)
   else : y   

;========== Mjolnir Width ==============
public definterface Width
public defstruct UnknownWidth <: Width : ()
public defstruct WidthVar <: Width :
   name: Symbol
public defstruct IntWidth <: Width :
   value: Int

;========= Mjolnir Primop ==============
val ops = HashTable<Symbol, PrimOp>(symbol-hash)

public defstruct PrimOp :
   name: Symbol
   arity: Int

defn fab-op (name: String, arity: Int) -> PrimOp :
  val sym = to-symbol(name)
  val res = PrimOp(sym, arity)
  ops[sym] = res
  res

public val ADD-OP = fab-op("ADD", 2)
public val ADD-MOD-OP = fab-op("ADD-MOD", 2)
public val MINUS-OP = fab-op("MINUS", 2)
public val SUB-MOD-OP = fab-op("SUB-MOD", 2)
public val TIMES-OP = fab-op("TIMES", 2)
public val DIVIDE-OP = fab-op("DIVIDE", 2)
public val MOD-OP = fab-op("MOD", 2)
public val SHIFT-LEFT-OP = fab-op("SHIFT-LEFT", 2)
public val SHIFT-RIGHT-OP = fab-op("SHIFT-RIGHT", 2)
public val PAD-OP = fab-op("PAD", 2)
public val BIT-AND-OP = fab-op("BIT-AND", 2)
public val BIT-OR-OP = fab-op("BIT-OR", 2)
public val BIT-XOR-OP = fab-op("BIT-XOR", 2)
public val CONCAT-OP = fab-op("CONCAT", 2)
public val BIT-SELECT-OP = fab-op("BIT-SELECT", 2)
public val BITS-SELECT-OP = fab-op("BITS-SELECT", 2)
public val MULTIPLEX-OP = fab-op("MULTIPLEX", 2)

public val LESS-OP = fab-op("LESS", 2)
public val LESS-EQ-OP = fab-op("LESS-EQ", 2)
public val GREATER-OP = fab-op("GREATER", 2)
public val GREATER-EQ-OP = fab-op("GREATER-EQ", 2)
public val EQUAL-OP = fab-op("EQUAL", 2)

;========= Mjolnir Immediate ===========
public definterface Immediate
public defmulti type (imm:Immediate) -> Type
public defmulti direction (imm:Immediate) -> Direction

public defstruct Ref <: Immediate :
   name: Symbol
   direction: Direction [multi => false]
   type: Type [multi => false]
public defn Ref (name:Symbol) :
   Ref(name, UNKNOWN-DIR, UnknownType())

public defstruct Field <: Immediate :
   imm: Immediate
   name: Symbol
   direction: Direction [multi => false]
   type: Type [multi => false]
public defn Field (imm:Immediate, name:Symbol) :
   Field(imm, name, UNKNOWN-DIR, UnknownType())


;Immediates referring to registers
public defstruct RegData <: Immediate :
   name: Symbol
   direction: Direction [multi => false]
   type: Type [multi => false]
public defn RegData (name: Symbol) :
   RegData(name, UNKNOWN-DIR, UnknownType())

public defstruct RegInit <: Immediate :
   name: Symbol
   direction: Direction [multi => false]
   type: Type [multi => false]
public defn RegInit (name: Symbol) :
   RegInit(name, UNKNOWN-DIR, UnknownType())


;Immediates referring to instance ports
public defstruct InstPort <: Immediate :
   name: Symbol
   port: Symbol
   direction: Direction [multi => false]
   type: Type [multi => false]
public defn InstPort (name:Symbol, port:Symbol) :
   InstPort(name, port, UNKNOWN-DIR, UnknownType())

;========= Putters =====================
;More to come ...
public defn put-imm (f:Field, i:Immediate) :
   Field(i, name(f), direction(f), type(f))

public defn put-type<?T> (i:?T&Immediate, t:Type) -> T :
   match(i) :
      (i:T&Ref) : Ref(name(i), direction(i), t) as T&Ref
      (i:T&Field) : Field(imm(i), name(i), direction(i), t) as T&Field
      (i:T&RegData) : RegData(name(i), direction(i), t) as T&RegData
      (i:T&RegInit) : RegInit(name(i), direction(i), t) as T&RegInit
      (i:T&InstPort) : InstPort(name(i), port(i), direction(i), t) as T&InstPort

public defn put-dir<?T> (i:?T&Immediate, d:Direction) -> T :
   match(i) :
      (i:T&Ref) : Ref(name(i), d, type(i)) as T&Ref
      (i:T&Field) : Field(imm(i), name(i), d, type(i)) as T&Field
      (i:T&RegData) : RegData(name(i), d, type(i)) as T&RegData
      (i:T&RegInit) : RegInit(name(i), d, type(i)) as T&RegInit
      (i:T&InstPort) : InstPort(name(i), port(i), d, type(i)) as T&InstPort

public defn put-width<?T> (t:?T&Type, w:Width) -> T :
   match(t) :
      (t:T&UIntType) : UIntType(w) as T&UIntType
      (t:T&SIntType) : SIntType(w) as T&SIntType

;======= Equivalence Relation ==========
;Does not consider direction and type.
public defn eqv? (i1:Immediate, i2:Immediate) :
   match(i1, i2) :
      (i1:Field, i2:Field) :
         eqv?(imm(i1), imm(i2)) and
         name(i1) == name(i2)
      (i1:Ref, i2:Ref) :
         name(i1) == name(i2)
      (i1:RegData, i2:RegData) :
         name(i1) == name(i2)
      (i1:RegInit, i2:RegInit) :
         name(i1) == name(i2)
      (i1:InstPort, i2:InstPort) :
         name(i1) == name(i2) and
         port(i1) == port(i2)
      (i1, i2) : false

;========== Mjolnir Port ===============
public defstruct Port :
   name: Symbol
   direction: Direction
   type: Type

public defn flip (p:Port) :
   Port(name(p), flip(direction(p)), type(p))

;========== Mjolnir Type ===============
public definterface Type 
public defmulti width (t:Type) -> Width

public defstruct UIntType <: Type :
   width: Width [multi => false]
public defn UIntType () :
   UIntType(UnknownWidth())

public defstruct SIntType <: Type :
   width: Width [multi => false]
public defn SIntType () :
   SIntType(UnknownWidth())
   
public defstruct BundleType <: Type :
   ports: List<Port>

public defstruct UnknownType <: Type

;========== Mjolnir Command ============
public definterface Command

public definterface HasName
public defmulti name (x:HasName) -> Symbol

public defstruct DefUInt <: Command & HasName :
   name: Symbol [multi => false]
   value: Int
   width: Width
public defstruct DefSInt <: Command & HasName :
   name: Symbol [multi => false]
   value: Int
   width: Width
public defstruct DoPrim <: Command & HasName :
   name: Symbol [multi => false]
   op: PrimOp
   args: List<Immediate>
   consts: List<Int>
public defstruct DefWire <: Command & HasName :
   name: Symbol [multi => false]
   type: Type
public defstruct DefRegister <: Command & HasName :
   name: Symbol [multi => false]
   type: Type
public defstruct DefInstance <: Command & HasName :
   name: Symbol [multi => false]
   module: Ref
public defstruct DefMemory <: Command & HasName :
   name: Symbol [multi => false]
   type: Type
   size: Int
public defstruct DefVector <: Command & HasName :
   name: Symbol [multi => false]
   type: Type
   args: List<Immediate>
public defstruct DefAccessor <: Command & HasName :
   name: Symbol [multi => false]
   source: Ref
   direction: Direction
   index: Immediate
public defstruct ConnectMany <: Command :
   idx: Immediate
   loc: Immediate
   exps: List<Immediate>
public defstruct ManyConnect <: Command :
   idx: Immediate
   locs: List<Immediate>
   exp: Immediate   
public defstruct Conditionally <: Command :
   pred: Immediate
   conseq: Command
   alt: Command
public defstruct Begin <: Command :
   body: List<Command>
public defstruct Connect <: Command :
   loc: Immediate
   exp: Immediate
public defstruct EmptyCommand <: Command : ()

;========== Mjolnir Module =============
public defstruct Module :
   name: Symbol
   ports: List<Port>
   body: Command

;========== Mjolnir Circuit ============
public defstruct Circuit :
   modules: List<Module>
   main: Symbol

;========== Indentation ================
defn IndentedStream (o:OutputStream, n:Int) :
   var indent? = true
   defn put (c:Char) :
      if indent? :
         do(print{o, " "}, 0 to n)
         indent? = false
      print(o, c)
      if c == \"\n" :
         indent? = true
      
   new OutputStream :
      defmethod print (this, s:String) : do(put, s)
      defmethod print (this, c:Char) : put(c)
   
defn indented (o:OutputStream, f: () -> ?) :
   val prev-stream = CURRENT-OUTPUT-STREAM
   dynamic-wind(
      fn () : CURRENT-OUTPUT-STREAM = IndentedStream(o, 3)
      f
      fn (f) : CURRENT-OUTPUT-STREAM = prev-stream)


;========== Mappers and Walkers ========
public defn map (f: (Immediate) -> Immediate, c: Command) -> Command :
   match(c) :
      (c:DoPrim) : DoPrim(name(c), op(c), map(f, args(c)), consts(c))
      (c:DefInstance) : DefInstance(name(c), f(module(c)) as Ref)
      (c:DefVector) : DefVector(name(c), type(c), map(f, args(c)))
      (c:DefAccessor) : DefAccessor(name(c), f(source(c)) as Ref, direction(c), f(index(c)))
      (c:ConnectMany) : ConnectMany(f(idx(c)), f(loc(c)), map(f, exps(c)))
      (c:ManyConnect) : ManyConnect(f(idx(c)), map(f, locs(c)), f(exp(c)))
      (c:Conditionally) : Conditionally(f(pred(c)), conseq(c), alt(c))
      (c:Connect) : Connect(f(loc(c)), f(exp(c)))
      (c) : c

public defn map (f: (Command) -> Command, c: Command) -> Command :
   match(c) :
      (c:Begin) :
         Begin(map(f, body(c)))
      (c:Conditionally) :
         Conditionally(pred(c), f(conseq(c)), f(alt(c)))
      (c) :
         c

public defn children (c: Command) -> Streamable<Command> :
   match(c) :
      (c:Begin) : body(c)
      (c:Conditionally) : [conseq(c) alt(c)]
      (c) : []

public defn map (f: (Type) -> Type, t: Type) -> Type :
   match(t) :
      (t:BundleType) :
         BundleType $
         for p in ports(t) map :
            Port(name(p), direction(p), f(type(p)))
      (t) :
         t

;======== Port Type Equal ==============
public defn eqv? (p1:Port, p2:Port) :
   name(p1) == name(p2) and
   direction(p1) == direction(p2) and
   eqv?(type(p1), type(p2))

;======== Type Similarity ==============
public defn eqv? (t1:Type, t2:Type) :
   match(t1, t2) :
      (t1:UnknownType, t2:UnknownType) : true
      (t1:UIntType, t2:UIntType) : true
      (t1:SIntType, t2:SIntType) : true
      (t1:BundleType, t2:BundleType) :
         length(ports(t1)) == length(ports(t2)) and
         all?(eqv?, ports(t1), ports(t2))

;========== Printing ===================
defmethod print (o:OutputStream, d:Direction) :
   print{o, _} $
   switch {d == _} :
      INPUT : "input"
      OUTPUT : "output"
      UNKNOWN-DIR : "?"

defmethod print (o:OutputStream, w:Width) :
   print{o, _} $
   match(w) :
      (w:UnknownWidth) : "?"
      (w:IntWidth) : value(w)
      (w:WidthVar) : name(w)
      (w) : error("Unable to print Width")

defmethod print (o:OutputStream, op:PrimOp) :
   print(o, name(op))

defmethod print (o:OutputStream, i:Immediate) :
   match(i) :
      (r:Ref) : print(o, name(r))
      (f:Field) : print-all(o, [imm(f) "." name(f)])
      (r:RegData) : print-all(o, [name(r) ".data"])
      (r:RegInit) : print-all(o, [name(r) ".init"])
      (p:InstPort) : print-all(o, [name(p) "." port(p)])

defmethod print (o:OutputStream, t:Type) :
   match(t) :
      (t:UnknownType) :
         print(o, "?")
      (t:UIntType) :
         print-all(o, ["UInt(" width(t) ")"])
      (t:BundleType) :
         print(o, "{")
         print-all(o, join(ports(t), ", "))
         print(o, "}")
      (t) :
         error("Unable to print type")

defmethod print (o:OutputStream, p:Port) :
   print-all(o, [direction(p) " " name(p) " : " type(p)])
      
defmethod print (o:OutputStream, c:Command) :
   match(c) :
      (c:DefUInt) :
         print-all(o, ["ulit " name(c) " = " value(c) " of width " width(c)])
      (c:DefSInt) :
         print-all(o, ["slit " name(c) " = " value(c) " of width " width(c)])
      (c:DoPrim) :
         print-all(o, ["prim " name(c) " = " op(c) "("])         
         print-all(o, join(concat(args(c), consts(c)), ", "))
         print(o, ")")         
      (c:DefWire) :
         print-all(o, ["wire " name(c) " : " type(c)])
      (c:DefRegister) :
         print-all(o, ["register " name(c) " : " type(c)])
      (c:DefInstance) :
         print-all(o, ["instance " name(c) " of " module(c)])
      (c:DefVector) :
         print-all(o, ["vec " name(c) " : " type(c) " of ("])
         print-all(o, join(args(c), ", "))
         print(o, ")")
      (c:DefAccessor) :
         print-all(o, ["accessor " name(c) " = " source(c) "[" index(c) "]"])
      (c:Connect) :
         print-all(o, ["connect " loc(c) " " exp(c)])
      (c:Conditionally) :
         println-all(o, ["when " pred(c) " :"])
         indented(o, print{conseq(c)})
         if alt(c) not-typeof EmptyCommand :
            println(o, "\nelse :")
            indented(o, print{alt(c)})
      (c:Begin) :
         do(print, join(body(c), "\n"))
      (c:EmptyCommand) :
         print(o, "skip")
      (c:ConnectMany) :
         print-all(o, ["many-connect " loc(c) " ("])
         print-all(o, join(exps(c), ", "))
         print-all(o, [")[" idx(c) "]"])
      (c:ManyConnect) :
         print-all(o, ["connect-many ("])
         print-all(o, join(locs(c), ", "))
         print-all(o, [")[" idx(c) "] " exp(c)])
      (c) :
         error("Unable to print command")

defmethod print (o:OutputStream, m:Module) :
   println-all(o, ["module " name(m) " :"])
   indented{o, _} $ fn () :
      do(println, ports(m))
      print(body(m))

defmethod print (o:OutputStream, c:Circuit) :
   println-all(o, ["circuit " main(c) " :"])
   indented(o, do{println, modules(c)})


defn is-var? (pattern:List) -> True|False :
  length(pattern) == 2 and pattern[0] == '@cap

defn match? (pattern, exp) -> [List<KeyValue>, List, True|False] :
  println-all(["MATCHING PAT " pattern " EXP " exp])
  val [kvs, rest, good?] =
    match(pattern) :
      (pat:List) :
        if is-var?(pat) :
          match(pat[1]) :
            (p:Symbol) : 
              [list(KeyValue(p, exp)), list(), true]
            (p) : 
              [List<KeyValue>(), list(), false]
        else if (pat == list()) :
          [List<KeyValue>(), exp, true]
        else if (head(pat) == '.) :
          match?(head(tail(pat)), exp)
        else if (exp == list()) :
          [List<KeyValue>(), list(), pat == list()]
        else :
          match(exp) :
            (e:List) :
              val [hvals, hrest, hgood] = match?(head(pat), head(exp))
              val [tvals, trest, tgood] = match?(tail(pat), tail(exp))
              [append(hvals, tvals), trest, hgood and tgood]
            (e) :
              [List<KeyValue>(), list(), false]
      (pat) :
        [List<KeyValue>(), list(), pat == exp]
  println-all(["MATCHING KVS " kvs " REST " rest " GOOD? " good?])
  [kvs, rest, good?]

defn parse-args (form: List<Symbol>) -> List<Immediate> :
  to-list(map(parse-immediate, form))

defn parse-ports (form: List) -> List<Port> :
  var elts : List = form
  val ports = Vector<Port>()
  while not empty?(elts) :
    val [port, rest] = parse-port(elts)
    match(port) :
      (port:Port) :
        add(ports, port)
        elts = rest
      (blub) :
        error("bad ports")
  to-list(ports)

defn parse-type (form: List) -> Type :
   println(">>> PARSING TYPE")
   ;; BUNDLE TYPES
   val [vals, rest, good?] = match?('(@do ?type ?width), form)
   if good? :
     ;; assert(good?, "bad type" and empty(rest))
     val width = IntWidth(lookup(vals, 'width) as Int)
     val kind =
       switch {lookup(vals, 'type) == _} :
         'UInt : UIntType(width)
         'SInt : SIntType(width)
     kind
   else :
     val [vals, rest, good?] = match?('((@afn . ?ports)), form)
     val ports = parse-ports(lookup(vals, 'ports) as List)     
     BundleType(ports)

defn parse-instance (form: List) -> [DefInstance, List] :
   println(">>> PARSING INSTANCE")
   val [vals, rest, good?] = match?('(instance ?name of ?module), form)
   ;; assert(good?, "bad prim")
   val mod-name : Symbol = lookup(vals, 'module)
   [DefInstance(lookup(vals, 'name), Ref(mod-name)), rest]

defn split (str: String, sep: Char) -> List<String> :
  val strs = Vector<String>()
  var last : Int = 0
  for i in 0 to length(str) do :
    if str[i] == sep :
      add(strs, substring(str, last, i))
      last = i + 1
  if last < length(str) :
    add(strs, substring(str, last, length(str)))
  to-list(strs)

defn parse-ref (form: Symbol) -> Ref :
  Ref(form)

defn parse-immediate (form) -> Immediate :
  defn syms-to-imm (x: List<Symbol>) -> Immediate :
    if length(x) == 1 :
      Ref(x[0])
    else :
      Field(syms-to-imm(tail(x)), head(x))
  val syms = map(to-symbol, split(to-string(form), "."[0]))
  syms-to-imm(syms)

defn parse-prim (form: List) -> [DoPrim, List] :
   println(">>> PARSING DOPRIM")
   val [vals, rest, good?] = match?('(prim ?name = (@do ?op . ?args)), form)
   ;; assert(good?, "bad prim")
   val lits = Vector<Int>()
   val args = parse-args(lookup(vals, 'args) as List<Symbol>)
   val op = ops[lookup(vals, 'op) as Symbol]
   [DoPrim(lookup(vals, 'name) as Symbol, op, args, to-list(lits)), rest]

defn parse-register (form: List) -> [DefRegister, List] :
   println(">>> PARSING REGISTER")
   val [vals, rest, good?] = match?('(register ?name : ?kind), form)
   ;; assert(good?, "bad register")
   [DefRegister(lookup(vals, 'name) as Symbol, parse-type(lookup(vals, 'kind))), rest]

defn parse-wire (form: List) -> [DefWire, List] :
   println(">>> PARSING WIRE")
   val [vals, rest, good?] = match?('(wire ?name : ?kind), form)
   ;; assert(good?, "bad wire")
   [DefWire(lookup(vals, 'name) as Symbol, parse-type(lookup(vals, 'kind))), rest]

defn parse-vec (form: List) -> [DefVector, List] :
   println(">>> PARSING VEC")
   val [vals, rest, good?] = match?('(vec ?name = ?kind of ?args), form)
   ;; assert(good?, "bad vec")
   val args = parse-args(lookup(vals, 'args) as List<Symbol>)
   [DefVector(lookup(vals, 'name) as Symbol, parse-type(lookup(vals, 'kind)), args), rest]

defn parse-accessor (form: List) -> [DefAccessor, List] :
   println(">>> PARSING ACCESSOR")
   val [vals, rest, good?] = match?('(accessor ?name = ?source (@get ?index )), form)
   ;; assert(good?, "bad accessor")
   [DefAccessor(lookup(vals, 'name) as Symbol, parse-ref(lookup(vals, 'source)), UNKNOWN-DIR, parse-immediate(lookup(vals, 'index))), rest]

defn parse-memory (form: List) -> [DefMemory, List] :
   println(">>> PARSING MEMORY")
   val [vals, rest, good?] = match?('(memory ?name : ?kind of size ?size ), form)
   ;; assert(good?, "bad memory")
   [DefMemory(lookup(vals, 'name) as Symbol, parse-type(lookup(vals, 'kind)), lookup(vals, 'size) as Int), rest]

defn parse-connect (form: List) -> [Connect, List] :
   println(">>> PARSING CONNECT")
   val [vals, rest, good?] = match?('(connect ?loc ?exp), form)
   ;; assert(good?, "bad connect")
   [Connect(parse-immediate(lookup(vals, 'loc)), parse-immediate(lookup(vals, 'exp))), rest]

defn parse-connect-many (form: List) -> [ConnectMany, List] :
   println(">>> PARSING CONNECT-MANY")
   val [vals, rest, good?] = match?('(connect-many ?loc ( . ?exps ) (@get ?idx)), form)
   ;; assert(good?, "bad connect-many")
   [ConnectMany(parse-immediate(lookup(vals, 'idx)), parse-immediate(lookup(vals, 'loc)), parse-args(lookup(vals, 'exps))), rest]

defn parse-many-connect (form: List) -> [ManyConnect, List] :
   println(">>> PARSING MANY-CONNECT")
   val [vals, rest, good?] = match?('(many-connect ( . ?locs ) (@get ?idx) ?exp ), form)
   ;; assert(good?, "bad connect-many")
   [ManyConnect(parse-immediate(lookup(vals, 'idx)), parse-args(lookup(vals, 'locs)), parse-immediate(lookup(vals, 'exp))), rest]

public defn to-command (commands: Vector<Command>) -> Command :
   val n = length(commands)
   switch {n == _} :
      0 : EmptyCommand()
      1 : commands[0]
      else : Begin(to-list(commands))

defn parse-commands (form: List) -> [Command, List] :
   val commands = Vector<Command>()
   var elts = form
   while not empty?(elts) :
     val [command, rest] = parse-command(elts)
     if command == false :
       error("Bad command")
     else :
       add(commands, command)
       elts = rest
   [to-command(commands), elts]

defn parse-else (form: List) -> [Command, List] :
   println(">>> PARSING ELSE")
   val [vals, rest, good?] = match?('(else : ?body), form)
   if good? :
     ;; assert(good?, "bad else")
     val [body, brest] = parse-commands(lookup(vals, 'body))
     [body, rest]
   else :
     [EmptyCommand(), rest]

defn parse-conditionally (form: List) -> [Conditionally, List] :
   println(">>> PARSING CONDITIONALLY")
   val [vals, rest, good?] = match?('(when ?cond : ?body), form)
   ;; assert(good?, "bad when")
   val [con, other] = parse-commands(lookup(vals, 'body))
   val [alt, arest] = parse-else(rest)
   [Conditionally(parse-immediate(lookup(vals, 'cond)), con, alt), arest]

defn parse-command (form: List) -> [Command, List] :
   switch {head(form) == _} :
     'prim         : parse-prim(form)
     'instance     : parse-instance(form)
     'register     : parse-register(form)
     'wire         : parse-wire(form)
     'vec          : parse-vec(form)
     'memory       : parse-memory(form)
     'accessor     : parse-accessor(form)
     'connect      : parse-connect(form)
     'connect-many : parse-connect-many(form)
     'many-connect : parse-many-connect(form)
     'when         : parse-conditionally(form)

defn parse-port (form: List) -> [Port|False, List] :
   println(">>> PARSING PORT")
   val [vals, rest, good?] = match?('(?dir ?name : ?kind), form)
   if good? : 
     val dir = 
       if lookup(vals, 'dir) == 'input : 
         INPUT 
       else if lookup(vals, 'dir) == 'output :
         OUTPUT
       else :
         UNKNOWN-DIR
     val name = lookup(vals, 'name) as Symbol
     val dir-good? = dir != UNKNOWN-DIR
     println-all(["PARSE PORT " dir-good?])
     [ Port(name, dir, parse-type(lookup(vals, 'kind))), rest ] when dir-good? else [ false, form ]
   else :
     [false, form]

defn parse-module (form: List) -> [Module, List] :
   println(">>> PARSING MODULE")
   val [vals, mod-rest, good?] = match?('(module ?name : ?body), form)
   if good? :
     val commands = Vector<Command>()
     val ports = Vector<Port>()
     var parsing-ports? : True|False = true
     var elts : List = lookup(vals, 'body)
     while not empty?(elts) :
       if parsing-ports? :
         val [port, rest] = parse-port(elts)
         match(port) :
           (port:Port) :
             add(ports, port)
             elts = rest
           (blub) :
             parsing-ports? = false
             println("FAILED TO PARSE PORT")
       if not parsing-ports? :
         val [command, rest] = parse-command(elts)
         if command == false :
           error("Bad command")
         else :
           add(commands, command)
           elts = rest
     val body = to-command(commands)
     [Module(lookup(vals, 'name) as Symbol, to-list(ports), body), mod-rest]
   else :
     error("bad circuit")

defn parse-circuit (form: List) -> Circuit :
   println(">>> PARSING CIRCUIT")
   val [vals, cir-rest, good?] = match?('(circuit ?name : ?body), form)
   if good? :
     println-all(["BODY " lookup(vals, 'body)])
     var body : List = lookup(vals, 'body)
     val mods = Vector<Module>()
     while not empty?(body) :
       val [mod, rest] = parse-module(body)
       body = rest
       add(mods, mod)
     Circuit(to-list(mods), lookup(vals, 'name) as Symbol)
   else :
     error("bad circuit")
   
public defn read-parse-file (filename: String) -> Circuit :
   var form:List = lex-file(filename)
   parse-circuit(unwrap-all(form))

