defpackage chipper.ir :
   import core
   import verse

;========= Mjolnir Direction ===========
public definterface Direction
public val INPUT = new Direction
public val OUTPUT = new Direction
public val UNKNOWN-DIR = new Direction

public defn flip (d:Direction) :
   switch {d == _} :
      INPUT : OUTPUT
      OUTPUT : INPUT
      UNKNOWN-DIR : UNKNOWN-DIR

public defn times (x:Direction, y:Direction) :
   if x == INPUT : flip(y)
   else : y   

;========== Mjolnir Width ==============
public definterface Width
public defstruct UnknownWidth <: Width : ()
public defstruct WidthVar <: Width :
   name: Symbol
public defstruct IntWidth <: Width :
   value: Int

;========= Mjolnir Primop ==============
public definterface PrimOp
public val ADD-OP = new PrimOp
public val MINUS-OP = new PrimOp
public val TIMES-OP = new PrimOp
public val DIVIDE-OP = new PrimOp
public val MOD-OP = new PrimOp
public val SHIFT-LEFT-OP = new PrimOp
public val SHIFT-RIGHT-OP = new PrimOp
public val BIT-AND-OP = new PrimOp
public val BIT-OR-OP = new PrimOp
public val BIT-XOR-OP = new PrimOp
public val CONCAT-OP = new PrimOp
public val BIT-SELECT-OP = new PrimOp
public val MULTIPLEX-OP = new PrimOp

public val LESS-OP = new PrimOp
public val LESS-EQ-OP = new PrimOp
public val GREATER-OP = new PrimOp
public val GREATER-EQ-OP = new PrimOp
public val EQUAL-OP = new PrimOp

;========= Mjolnir Immediate ===========
public definterface Immediate
public defmulti type (imm:Immediate) -> Type
public defmulti direction (imm:Immediate) -> Direction

public defstruct Ref <: Immediate :
   name: Symbol
   direction: Direction [multi => false]
   type: Type [multi => false]
public defn Ref (name:Symbol) :
   Ref(name, UNKNOWN-DIR, UnknownType())
   
public defstruct Field <: Immediate :
   imm: Immediate
   name: Symbol
   direction: Direction [multi => false]
   type: Type [multi => false]
public defn Field (imm:Immediate, name:Symbol) :
   Field(imm, name, UNKNOWN-DIR, UnknownType())

public defn eqv? (i1:Immediate, i2:Immediate) :
   match(i1, i2) :
      (i1:Field, i2:Field) : eqv?(imm(i1), imm(i2)) and name(i1) == name(i2)
      (i1:Ref, i2:Ref) : name(i1) == name(i2)
      (i1, i2) : false

;========== Mjolnir Port ===============
public defstruct Port :
   name: Symbol
   direction: Direction
   type: Type

public defn flip (p:Port) :
   Port(name(p), flip(direction(p)), type(p))

;========== Mjolnir Type ===============
public definterface Type 

public defstruct UnknownType <: Type : ()

public defstruct IntType <: Type :
   width: Width 

public defstruct SIntType <: Type :
   width: Width
   
public defstruct BundleType <: Type :
   ports: List<Port>

;========== Mjolnir Command ============
public definterface Command

public definterface HasName
public defmulti name (x:HasName) -> Symbol

public defstruct DefInt <: Command & HasName :
   name: Symbol [multi => false]
   value: Int
public defstruct DefSInt <: Command & HasName :
   name: Symbol [multi => false]
   value: Int
public defstruct DoPrim <: Command & HasName :
   name: Symbol [multi => false]
   op: PrimOp
   args: List<Immediate>
public defstruct DefWire <: Command & HasName :
   name: Symbol [multi => false]
   type: Type
public defstruct DefRegister <: Command & HasName :
   name: Symbol [multi => false]
   type: Type
public defstruct DefInstance <: Command & HasName :
   name: Symbol [multi => false]
   module: Ref
public defstruct DefMemory <: Command & HasName :
   name: Symbol [multi => false]
   type: Type
   size: Int
public defstruct DefVector <: Command & HasName :
   name: Symbol [multi => false]
   type: Type
   args: List<Immediate>
public defstruct DefAccessor <: Command & HasName :
   name: Symbol [multi => false]
   source: Ref
   direction: Direction
   index: Immediate
public defstruct ConnectMany <: Command :
   idx: Immediate
   loc: Immediate
   exps: List<Immediate>
public defstruct ManyConnect <: Command :
   idx: Immediate
   locs: List<Immediate>
   exp: Immediate   
public defstruct Conditionally <: Command :
   pred: Immediate
   conseq: Command
   alt: Command
public defstruct Begin <: Command :
   body: List<Command>
public defstruct Connect <: Command :
   loc: Immediate
   exp: Immediate
public defstruct EmptyCommand <: Command : ()

;========== Mjolnir Module =============
public defstruct Module :
   name: Symbol
   ports: List<Port>
   body: Command

;========== Mjolnir Circuit ============
public defstruct Circuit :
   modules: List<Module>
   main: Symbol


;========== Indentation ================
defn IndentedStream (o:OutputStream, n:Int) :
   var indent? = true
   defn put (c:Char) :
      if indent? :
         do(print{o, " "}, 0 to n)
         indent? = false
      print(o, c)
      if c == \"\n" :
         indent? = true
      
   new OutputStream :
      defmethod print (this, s:String) : do(put, s)
      defmethod print (this, c:Char) : put(c)
   
defn indented (o:OutputStream, f: () -> ?) :
   val prev-stream = CURRENT-OUTPUT-STREAM
   dynamic-wind(
      fn () : CURRENT-OUTPUT-STREAM = IndentedStream(o, 3)
      f
      fn (f) : CURRENT-OUTPUT-STREAM = prev-stream)


;========== Mappers and Walkers ========
public defn map (f: (Immediate) -> Immediate, c: Command) -> Command :
   match(c) :
      (c:DoPrim) : DoPrim(name(c), op(c), map(f, args(c)))
      (c:DefInstance) : DefInstance(name(c), f(module(c)) as Ref)
      (c:DefVector) : DefVector(name(c), type(c), map(f, args(c)))
      (c:DefAccessor) : DefAccessor(name(c), f(source(c)) as Ref, direction(c), f(index(c)))
      (c:ConnectMany) : ConnectMany(f(idx(c)), f(loc(c)), map(f, exps(c)))
      (c:ManyConnect) : ManyConnect(f(idx(c)), map(f, locs(c)), f(exp(c)))
      (c:Conditionally) : Conditionally(f(pred(c)), conseq(c), alt(c))
      (c:Connect) : Connect(f(loc(c)), f(exp(c)))
      (c) : c

public defn map (f: (Command) -> Command, c: Command) -> Command :
   match(c) :
      (c:Begin) :
         Begin(map(f, body(c)))
      (c:Conditionally) :
         Conditionally(pred(c), f(conseq(c)), f(alt(c)))
      (c) :
         c

public defn children (c: Command) -> Streamable<Command> :
   match(c) :
      (c:Begin) : body(c)
      (c:Conditionally) : [conseq(c) alt(c)]
      (c) : []

public defn map (f: (Type) -> Type, t: Type) -> Type :
   match(t) :
      (t:BundleType) :
         BundleType $
         for p in ports(t) map :
            Port(name(p), direction(p), f(type(p)))
      (t) :
         t

;======== Port Type Equal ==============
public defn type-equal? (p1:Port, p2:Port) :
   name(p1) == name(p2) and
   direction(p1) == direction(p2) and
   type-equal?(type(p1), type(p2))

;======== Type Similarity ==============
public defn type-equal? (t1:Type, t2:Type) :
   match(t1, t2) :
      (t1:UnknownType, t2:UnknownType) : true
      (t1:IntType, t2:IntType) : true
      (t1:SIntType, t2:SIntType) : true
      (t1:BundleType, t2:BundleType) :
         length(ports(t1)) == length(ports(t2)) and
         all?(type-equal?, ports(t1), ports(t2))

;========== Printing ===================
defmethod print (o:OutputStream, d:Direction) :
   print{o, _} $
   switch {d == _} :
      INPUT : "input"
      OUTPUT : "output"
      UNKNOWN-DIR : "?"

defmethod print (o:OutputStream, w:Width) :
   print{o, _} $
   match(w) :
      (w:UnknownWidth) : "?"
      (w:IntWidth) : value(w)
      (w:WidthVar) : name(w)
      (w) : error("Unable to print Width")

defmethod print (o:OutputStream, op:PrimOp) :
   print{o, _} $
   switch {op == _} :
      ADD-OP : "Add"
      MINUS-OP : "Minus"
      TIMES-OP : "Times"
      DIVIDE-OP : "Divide"
      MOD-OP : "Mod"
      SHIFT-LEFT-OP : "ShiftLeft"
      SHIFT-RIGHT-OP : "ShiftRight"
      BIT-AND-OP : "BitAnd"
      BIT-OR-OP : "BitOr"
      BIT-XOR-OP : "BitXor"
      CONCAT-OP : "Concat"
      BIT-SELECT-OP : "Select"
      LESS-OP : "Less"
      LESS-EQ-OP : "LessEq"
      GREATER-OP : "Greater"
      GREATER-EQ-OP : "GreaterEq"
      EQUAL-OP : "Equal"
      MULTIPLEX-OP : "Multiplex"
      else : error("Unable to print Primop")

if-not-defined(PRINT-TYPES) :
   defmethod print (o:OutputStream, i:Immediate) :
      match(i) :
         (r:Ref) : print(o, name(r))
         (f:Field) : print-all(o, [imm(f) "." name(f)])
else : 
   defmethod print (o:OutputStream, i:Immediate) :
      match(i) :
         (r:Ref) :
            print-all{o, _} $ [
               name(r) "(" type(r) ")"]
         (f:Field) :
            print-all{o, _} $ [
               imm(f) "." name(f) "(" type(f) ")"]

defmethod print (o:OutputStream, t:Type) :
   match(t) :
      (t:UnknownType) :
         print(o, "?")
      (t:IntType) :
         print-all(o, ["Int(" width(t) ")"])
      (t:BundleType) :
         print(o, "{")
         print-all(o, join(ports(t), ", "))
         print(o, "}")
      (t) :
         error("Unable to print type")

defmethod print (o:OutputStream, p:Port) :
   print-all(o, [direction(p) " " name(p) " : " type(p)])
      
defmethod print (o:OutputStream, c:Command) :
   match(c) :
      (c:DefInt) :
         print-all(o, ["node " name(c) " = " value(c)])
      (c:DefSInt) :
         print-all(o, ["node " name(c) " = " value(c)])
      (c:DoPrim) :
         print-all(o, ["node " name(c) " = " op(c) "("])
         print-all(o, join(args(c), ", "))
         print(o, ")")         
      (c:DefWire) :
         print-all(o, ["wire " name(c) " : " type(c)])
      (c:DefRegister) :
         print-all(o, ["register " name(c) " : " type(c)])
      (c:DefInstance) :
         print-all(o, ["instance " name(c) " of " module(c)])
      (c:DefVector) :
         print-all(o, ["vec " name(c) " : " type(c) " of ("])
         print-all(o, join(args(c), ", "))
         print(o, ")")
      (c:DefAccessor) :
         print-all(o, ["accessor " name(c) " = " source(c) "[" index(c) "]"])
      (c:Connect) :
         print-all(o, [loc(c) " := " exp(c)])
      (c:Conditionally) :
         println-all(o, ["when " pred(c) " :"])
         indented(o, print{conseq(c)})
         if alt(c) not-typeof EmptyCommand :
            println(o, "\nelse :")
            indented(o, print{alt(c)})
      (c:Begin) :
         do(print, join(body(c), "\n"))
      (c:EmptyCommand) :
         print(o, "skip")
      (c:ConnectMany) :
         print-all(o, [loc(c) " := ("])
         print-all(o, join(exps(c), ", "))
         print-all(o, [")[" idx(c) "]"])
      (c:ManyConnect) :
         print-all(o, ["("])
         print-all(o, join(locs(c), ", "))
         print-all(o, [")[" idx(c) "] := " exp(c)])
      (c) :
         error("Unable to print command")

defmethod print (o:OutputStream, m:Module) :
   println-all(o, ["module " name(m) " :"])
   indented{o, _} $ fn () :
      do(println, ports(m))
      print(body(m))

defmethod print (o:OutputStream, c:Circuit) :
   println-all(o, ["circuit " main(c) " :"])
   indented(o, do{println, modules(c)})






