defpackage chipper.passes:
  import core
  import verse
  import chipper.ir
  import widthsolver

;============== EXCEPTIONS =================================
defclass PassException <: Exception
defn PassException (msg:String) :
  new PassException :
    defmethod print (o:OutputStream, this) :
      print(o, msg)

;================ UTILITIES ================================
defn lookup<?T> (e: Streamable<KeyValue<Immediate,?T>>, i:Immediate) :
   for entry in e search :
      if eqv?(key(entry), i) :
         value(entry)

defn* root-ref (i:Immediate) :
   match(i) :
      (f:Field) : root-ref(imm(f))
      (r:Ref) : r

defn replace-root (i:Immediate, root:Immediate) :
   match(i) :
      (r:Ref) : root
      (f:Field) :
         Field{_, name(f), direction(f), type(f)} $
         replace-root(imm(f), root)

defn replace-root (i:Immediate, old-root:Immediate, new-root:Immediate) :
   match(i, old-root) :
      (i:Field, r:Field) :
         if eqv?(i, r) : new-root
         else :
            val imm* = replace-root(imm(i), r, new-root)
            Field(imm*, name(i))
      (i:Ref, r:Ref) :
         if eqv?(i, r) : new-root
         else : i
      (i, r) :
         i

;============ CHECK IF NAMES ARE UNIQUE ====================
defn check-duplicate-symbols (names: Streamable<Symbol>, msg: String) :
  val dict = HashTable<Symbol, True>(symbol-hash)
  for name in names do:
    if key?(dict, name):
      throw $ PassException $ string-join $
      [msg ": " name]
    else:
      dict[name] = true

defn check-duplicates (t: Type) :
  match(t) :
    (t:BundleType) :
      val names = map(name, ports(t))
      check-duplicate-symbols{names, string-join(_)} $
        ["Duplicate port name in bundle "]
      do(check-duplicates{type(_)}, ports(t))
    (t) : false

defn check-duplicates (c: Command) :
  match(c) :
    (c:DefWire) : check-duplicates(type(c))
    (c:DefRegister) : check-duplicates(type(c))
    (c:DefMemory) : check-duplicates(type(c))
    (c:DefVector) : check-duplicates(type(c))
    (c) : do(check-duplicates, children(c))

defn defined-names (c: Command) :
  generate<Symbol> :
    loop(c) where :
      defn loop (c:Command) :
        match(c) :
          (c:Command&HasName) : yield(name(c))
          (c) : do(loop, children(c))

defn check-duplicates (m: Module):
  ;Check all duplicate names in all types in all ports and body
  do(check-duplicates{type(_)}, ports(m))
  check-duplicates(body(m))

  ;Check all names defined in module
  val names = concat(stream(name, ports(m)),
                     defined-names(body(m)))
  check-duplicate-symbols{names, string-join(_)} $
    ["Duplicate definition name in module " name(m)]

defn check-duplicates (c: Circuit) :
  ;Check all duplicate names in all modules
  do(check-duplicates, modules(c))

  ;Check all defined modules
  val names = stream(name, modules(c))
  check-duplicate-symbols(names, "Duplicate module name")


;=============== MAKE RESET EXPLICIT =======================
defn make-explicit-reset (c: Command) -> Command :
   match(c) :
      (c:DefInstance) :
         val c2 = Connect(Field(Ref(name(c)), 'reset),
                          Field(Ref('this), 'reset))
         Begin(list(c, c2))
      (c) :
         map(make-explicit-reset{_ as Command}, c)

defn make-explicit-reset (m: Module) :
   val reset = Port('reset, INPUT, IntType(IntWidth(1)))
   Module(name(m),
          List(reset, ports(m)),
          make-explicit-reset(body(m)))

defn make-explicit-reset (c: Circuit) :
   val modules* = map(make-explicit-reset, modules(c))
   Circuit(modules*, main(c))


;======= MAKE EXPLICIT REGISTER INITIALIZATION =============
defn reg-inits (e: List<KeyValue<Immediate,Immediate>>) :
   if empty?(e) :
      EmptyCommand()
   else :
      val connections = Begin $ to-list $
         for entry in e map :
            Connect(key(entry), value(entry))
      Conditionally(
         Field(Ref('this), 'reset),
         connections,
         EmptyCommand())

;e is a mapping of (register => init wire)
defn initialize-registers (c: Command
                           e: List<KeyValue<Immediate,Immediate>>) ->
                           [Command, List<KeyValue<Immediate,Immediate>>] :

   defn replace-reg-ports (i:Immediate) :
      match(lookup(e, root-ref(i))) :
         (wire:Immediate) :
            val reg = root-ref(i)
            replace-root{_, Field(reg, 'data), reg} $
               replace-root(i, Field(reg, 'init), wire)
         (f:False) :
            i

   match(c) :
      (c:DefRegister) :
         val reg = Ref(name(c))
         val init = Ref $ gensym $ string-join $ [name(c) "-init"]
         val c* = Begin $ to-list $ [
            c,
            DefWire(name(init), type(c))
            Connect(init, reg)]
         [c*, list(reg => init)]
      (c:Conditionally) :
         val pred* = replace-reg-ports(pred(c))
         val [conseq* con-e] = initialize-registers(conseq(c), e)
         val [alt* alt-e] = initialize-registers(alt(c), e)
         val c* =
            Conditionally(
               pred*
               Begin(list(conseq*, reg-inits(con-e)))
               Begin(list(alt*, reg-inits(alt-e))))
         [c*, List()]
      (c:Begin) :
         var current-e: List<KeyValue<Immediate,Immediate>> = e
         val defined = Vector<KeyValue<Immediate,Immediate>>()
         val body* =
            for c in body(c) map :
               val [c* e*] = initialize-registers(c, current-e)
               current-e = append(e*, current-e)
               do(add{defined, _}, e*)
               c*
         [Begin(body*), to-list(defined)]
      (c) :
         [map(replace-reg-ports, c), List()]

defn initialize-registers (m:Module) :
   val body* = let :
      val [body* regs] = initialize-registers(body(m), List())
      Begin(list(body*, reg-inits(regs)))
   Module(name(m), ports(m), body*)

defn initialize-registers (c:Circuit) :
   val modules* = map(initialize-registers, modules(c))
   Circuit(modules*, main(c))


;============= INFER TYPES FOR ALL IMMEDIATES ==============
defn lookup-port (ports: Streamable<Port>, port-name: Symbol) :
   for port in ports find :
      name(port) == port-name

defn lookup-port! (ports: Streamable<Port>, port-name: Symbol) :
  match(lookup-port(ports, port-name)) :
    (p:Port) : p
    (p:False) :
      error $ string-join $
        ["No port found with name: " port-name "."]

defn lookup-ref (e: Streamable<Ref>, n:Symbol) :
   for entry in e find :
      name(entry) == n

defn lookup-ref! (e: Streamable<Ref>, n:Symbol) :
   match(lookup-ref(e, n)) :
      (r:Ref) : r
      (r:False) : error $ string-join $
                  ["No ref exists with name: " n]

defn infer (i: Immediate, e: List<Ref>) -> Immediate :
  match(i) :
    (r:Ref) :
       lookup-ref!(e, name(r))
    (f:Field) :
       val imm* = infer(imm(f), e)
       val [port-type, port-dir] =
          match(type(imm*)) :
             (t:BundleType) :
                match(lookup-port(ports(t), name(f))) :
                   (p:Port) : [type(p), direction(p)]
                   (p) : [type(f), UNKNOWN-DIR]
             (t) :
                [type(f), UNKNOWN-DIR]
       Field(imm*, name(f), direction(imm*) * port-dir, port-type)

defn infer (p:PrimOp, arg-types: List<Type>) -> Type :
  IntType(UnknownWidth())

defn infer (c:Command, in-e: List<Ref>, out-e: List<Ref>) -> [Command, List<Ref>, List<Ref>] :
   match(c) :
      (c:DefInt|DefSInt) :
         val ref = Ref(name(c), OUTPUT, IntType(UnknownWidth()))
         [c, List(ref, in-e), List(ref, out-e)]
      (c:DefWire) :
         val in-ref = Ref(name(c), INPUT, type(c))
         val out-ref = Ref(name(c), OUTPUT, type(c))
         [c, List(in-ref, in-e), List(out-ref, out-e)]
      (c:DefRegister) :
         val in-ref = Ref(name(c), INPUT, type(c))
         val out-ref = Ref(name(c), OUTPUT, type(c))
         [c, List(in-ref, in-e), List(out-ref, out-e)]
      (c:DefMemory) :
         val in-ref = Ref(name(c), INPUT, type(c))
         val out-ref = Ref(name(c), OUTPUT, type(c))
         [c, List(in-ref, in-e), List(out-ref, out-e)]
      (c:DefVector) :
         val args* = map({infer(_, out-e)}, args(c))
         val in-ref = Ref(name(c), INPUT, type(c))
         val out-ref = Ref(name(c), OUTPUT, type(c))
         [DefVector(name(c), type(c), args*), List(in-ref, in-e), List(out-ref, out-e)]
      (c:DefAccessor) :
         val source* = let :
            val s = infer(source(c), out-e) as Ref
            Ref(name(s), UNKNOWN-DIR, type(s))
         val index* = infer(index(c), out-e)
         val in-ref = Ref(name(c), INPUT, type(source*))
         val out-ref = Ref(name(c), OUTPUT, type(source*))
         [DefAccessor(name(c), source*, UNKNOWN-DIR, index*), List(in-ref, in-e), List(out-ref, out-e)]
      (c:DefInstance) :
         val module* = infer(module(c), out-e) as Ref
         val ref = Ref(name(c), direction(module*), type(module*))
         [DefInstance(name(c), module*), List(ref, in-e), List(ref, out-e)]
      (c:Conditionally) :
         val pred* = infer(pred(c), out-e)
         val [con*, con-in-e, con-out-e] = infer(conseq(c), in-e, out-e)
         val [alt*, alt-in-e, alt-out-e] = infer(alt(c), in-e, out-e)
         [Conditionally(pred*, con*, alt*), in-e, out-e]
      (c:Begin) :
         var current-in-e: List<Ref> = in-e
         var current-out-e: List<Ref> = out-e
         val body* = for c in body(c) map :
            val [c*, in-e, out-e] = infer(c, current-in-e, current-out-e)
            current-in-e = in-e
            current-out-e = out-e
            c*
         [Begin(body*), current-in-e, current-out-e]
      (c:Connect) :
         val loc* = infer(loc(c), in-e)
         val exp* = infer(exp(c), out-e)
         [Connect(loc*, exp*), in-e, out-e]
      (c:DoPrim) :
         val args* = map(infer{_, out-e}, args(c))
         val type* = infer(op(c), map(type, args*))
         val ref = Ref(name(c), OUTPUT, type*)
         [DoPrim(name(c), op(c), args*), List(ref, in-e), List(ref, out-e)]
      (c:ConnectMany) :
         val idx* = infer(idx(c), out-e)
         val loc* = infer(loc(c), in-e)
         val exps* = map(infer{_, out-e}, exps(c))
         [ConnectMany(idx*, loc*, exps*), in-e, out-e]
      (c:ManyConnect) :
         val idx* = infer(idx(c), out-e)
         val locs* = map(infer{_, in-e}, locs(c))
         val exp* = infer(exp(c), out-e)
         [ManyConnect(idx*, locs*, exp*), in-e, out-e]
      (c:EmptyCommand) : [c, in-e, out-e]

defn infer (m: Module, e: List<Ref>) -> Module :
   val ref = lookup-ref!(e, name(m))
   val m-env = List(Ref('this, INPUT, type(ref)), e)
   val [body*, in-env*, out-env*] = infer(body(m), m-env, m-env)
   Module(name(m), ports(m), body*)

defn infer-types (c: Circuit) -> Circuit :
   val env =
      for m in modules(c) map :
         Ref(name(m), OUTPUT, BundleType(ports(m)))
   val modules* = map(infer{_, env}, modules(c))
   Circuit(modules*, main(c))

;========= INFER DIRECTIONS OF ACCESSORS ===================
defn find-accessor-uses (c:Command) :
   to-list $ generate<Ref> :
      val accessors = Vector<Symbol>()
      defn find-use (imm:Immediate) :
         val root = root-ref(imm)
         yield(root) when contains?(accessors, name(root))
         imm
      loop(c) where :
         defn loop (c:Command) :
            match(map(find-use, c)) :
               (c:DefAccessor) : add(accessors, name(c))
               (c) : do(loop, children(c))

defn fold-accessor-uses (uses: List<Ref>) :
   val table = HashTable<Symbol,Ref>(symbol-hash)
   for use in uses do :
      match(get?(table, name(use), false)) :
         (r:Ref) :
            if direction(r) != direction(use) :
               throw $ PassException $ string-join $
               ["Accessor " name(use) " is used both as an INPUT and an OUTPUT."]
         (f:False) :
            table[name(use)] = use
   to-list(stream(value, table))

defn fill-accessor-dirs (c:Command, uses:List<Ref>) -> Command :
   match(c) :
      (c:DefAccessor) :
         val dir =
            match(lookup-ref(uses, name(c))) :
               (r:Ref) : direction(r)
               (d:False) : throw $ PassException $ string-join $
                           ["Accessor " name(c) " is never used. Unable to infer direction."]
         DefAccessor(name(c), source(c), dir, index(c))
      (c:Command) :
         map(fill-accessor-dirs{_, uses}, c)

defn infer-accessor-dirs (c:Circuit) :
   val modules* =
      for m in modules(c) map :
         val uses = fold-accessor-uses(find-accessor-uses(body(m)))
         val body* = fill-accessor-dirs(body(m), uses)
         Module(name(m), ports(m), body*)
   Circuit(modules*, main(c))


;============== EXPAND VECS ================================
defn lookup-vector (vecs: Streamable<DefVector>, n:Symbol) :
   for v in vecs find :
      name(v) == n

defn expand-vecs (c: Command) :
   val vecs = Vector<DefVector>()
   defn expand (c:Command) :
      match(c) :
         (c:DefAccessor) :
            match(lookup-vector(vecs, name(source(c)))) :
               (vec:DefVector) :
                  switch {direction(c) == _} :
                     OUTPUT :
                        Begin $ to-list $ [
                           DefWire(name(c), type(source(c)))
                           ConnectMany(index(c), Ref(name(c)), args(vec))]
                     INPUT :
                        Begin $ to-list $ [
                           DefWire(name(c), type(source(c)))
                           ManyConnect(index(c), args(vec), Ref(name(c)))]
               (vec:False) :
                  c
         (c:DefVector) :
            add(vecs, c)
            EmptyCommand()
         (c) :
            map(expand, c)
   expand(c)

defn expand-vecs (c:Circuit) :
   val modules* =
      for m in modules(c) map :
         Module(name(m), ports(m), expand-vecs(body(m)))
   Circuit(modules*, main(c))



;=============== BUNDLE FLATTENING =========================
defn flatten-ports (p:Port) -> List<Port> :
   match(type(p)) :
      (t:BundleType) :
         val ports = map-append(flatten-ports, ports(t))
         for port in ports map :
            val name* = symbol-join([name(p) "/" name(port)])
            Port(name*, direction(p) * direction(port), type(port))
      (t:Type) :
         list(p)

defn flatten-type (t:Type) -> Type :
   match(t) :
      (t:BundleType) :
         BundleType $
         map-append(flatten-ports, ports(t))
      (t:Type) :
         t

defn flatten-imm (i:Immediate) -> Immediate :
   match(i) :
      (r:Ref) : Ref(name(r), direction(r), flatten-type(type(r)))
      (f:Field) : Field(flatten-imm(imm(f)), name(f), direction(f), flatten-type(type(f)))

defn flatten-command (c: Command) -> Command :
   match(map(flatten-imm, c)) :
      (c:DefWire) : DefWire(name(c), flatten-type(type(c)))
      (c:DefRegister) : DefRegister(name(c), flatten-type(type(c)))
      (c:DefMemory) : DefMemory(name(c), flatten-type(type(c)), size(c))
      (c) : map(flatten-command, c)

defn flatten-bundles (m: Module) :
   val ports* = map-append(flatten-ports, ports(m))
   val body* = flatten-command(body(m))
   Module(name(m), ports*, body*)

defn flatten-bundles (c: Circuit) :
   Circuit(map(flatten-bundles, modules(c)), main(c))



;================== BUNDLE EXPANSION =======================
defn expand-imm-bundles (i:Immediate, instances:Vector<Symbol>) -> List<Immediate> :
   defn* collapse-ref (i:Immediate) :
      match(i) :
         (i:Ref) : i
         (i:Field) :
            match(imm(i)) :
               (r:Ref) :
                  if contains?(instances, name(r)) :
                     i
                  else :
                     val name = symbol-join $ [name(r) "/" name(i)]
                     Ref(name, direction(i), type(i))
               (f:Field) :
                  val fname = symbol-join $ [name(f) "/" name(i)]
                  collapse-ref(Field(imm(f), fname, direction(i), type(i)))

   match(type(i)) :
      (t:BundleType) :
         for port in ports(t) map :
            val dir* = direction(i) * direction(port)
            collapse-ref(Field(i, name(port), dir*, type(port)))
      (t) :
         list(collapse-ref(i))

defn expand-mem-bundles (m: DefMemory) -> Command :
   match(type(m)) :
      (t:BundleType) :
         Begin $
         for p in ports(t) map :
            val name = symbol-join $ [name(m) "/" name(p)]
            DefMemory(name, type(p), size(m))
      (t) :
         m

defn expand-accessor-bundles (a: DefAccessor, instances:Vector<Symbol>) -> Command :
   match(type(source(a))) :
      (t:BundleType) :
         val sources = expand-imm-bundles(source(a), instances)
         Begin $
         for (p in ports(t), s in sources) map :
            val name = symbol-join $ [name(a) "/" name(p)]
            DefAccessor(name, s as Ref, direction(a), index(a))
      (t) :
         a

defn expand-connect-many (c:ConnectMany, instances:Vector<Symbol>) -> Command :
   val locs = expand-imm-bundles(loc(c), instances)
   val exps-list = transpose(map(expand-imm-bundles{_, instances}, exps(c)))
   Begin $
   for (loc in locs, exps in exps-list) map :
      switch {direction(loc) == _} :
         INPUT : ConnectMany(idx(c), loc, exps)
         OUTPUT : ManyConnect(idx(c), exps, loc)

defn expand-many-connect (c:ManyConnect, instances:Vector<Symbol>) -> Command :
   val locs-list = transpose(map(expand-imm-bundles{_, instances}, locs(c)))
   val exps = expand-imm-bundles(exp(c), instances)
   Begin $
   for (locs in locs-list, exp in exps) map :
      switch {direction(exp) == _} :
         OUTPUT : ManyConnect(idx(c), locs, exp)
         INPUT : ConnectMany(idx(c), exp, locs)

defn expand-connect (c:Connect, instances:Vector<Symbol>) -> Command :
   val locs = expand-imm-bundles(loc(c), instances)
   val exps = expand-imm-bundles(exp(c), instances)
   Begin $
   for (loc in locs, exp in exps) map :
      switch {direction(loc) == _} :
         INPUT : Connect(loc, exp)
         OUTPUT : Connect(exp, loc)

defn expand-wires (c:DefWire) -> Command :
   match(type(c)) :
      (t:BundleType) :
         Begin $
         for p in ports(t) map :
            val name = symbol-join $ [name(c) "/" name(p)]
            DefWire(name, type(p))
      (t) :
         c

defn expand-registers (c:DefRegister) -> Command :
   match(type(c)) :
      (t:BundleType) :
         Begin $
         for p in ports(t) map :
            val name = symbol-join $ [name(c) "/" name(p)]
            DefRegister(name, type(p))
      (t) :
         c

defn expand-bundles (c:Command, instances:Vector<Symbol>) -> Command :
   match(c) :
      (c:DefWire) : expand-wires(c)
      (c:DefRegister) : expand-registers(c)
      (c:DefMemory) : expand-mem-bundles(c)
      (c:DefAccessor) : expand-accessor-bundles(c, instances)
      (c:ConnectMany) : expand-connect-many(c, instances)
      (c:ManyConnect) : expand-many-connect(c, instances)
      (c:Connect) : expand-connect(c, instances)
      (c) : map(expand-bundles{_, instances}, c)

defn expand-bundles (m:Module) :
   ;Find all instances
   val instances = Vector<Symbol>()
   add(instances, 'this)
   loop(body(m)) where :
      defn loop (c:Command) :
         match(c) :
            (c:DefInstance) : add(instances, name(c))
            (c) : do(loop, children(c))
   ;Expand body
   val body* = expand-bundles(body(m), instances)
   Module(name(m), ports(m), body*)

defn expand-circuit-bundles (c:Circuit) :
   val c* = flatten-bundles(c)
   Circuit(map(expand-bundles, modules(c*)), main(c*))

;================ CLEANUP COMMANDS =========================
defn cleanup-command (c:Command) :
   match(c) :
      (c:Begin) :
         val cs = to-list $ generate<Command> :
            loop(c) where :
               defn loop (c:Command) :
                  match(c) :
                     (c:Begin) : do(loop, body(c))
                     (c:EmptyCommand) : false
                     (c) : yield(cleanup-command(c))
         switch {length(cs) == _} :
            0 : EmptyCommand()
            1 : head(cs)
            else : Begin(cs)
      (c) : map(cleanup-command, c)

defn cleanup-circuit (c:Circuit) :
   val modules* =
      for m in modules(c) map :
         Module(name(m), ports(m), cleanup-command(body(m)))
   Circuit(modules*, main(c))


;=========== CONVERT MULTI CONNECTS to WHEN ================
defn convert-connect-many (c:ConnectMany|ManyConnect) :
   Begin{to-list(_)} $
   generate<Command> :
      defn make-int (i:Int) :
         val name = gensym()
         yield(DefInt(name, i))
         Ref(name)
      defn compare (x:Immediate, i:Int) :
         val name = gensym()
         yield(DoPrim(name, EQUAL-OP, list(x, make-int(i))))
         Ref(name)
      match(c) :
         (c:ConnectMany) :
            for (i in 0 to false, exp in exps(c)) do :
               yield $
               Conditionally(compare(idx(c), i),
                  Connect(loc(c), exp)
                  EmptyCommand())
         (c:ManyConnect) :
            for (i in 0 to false, loc in locs(c)) do :
               yield $
               Conditionally(compare(idx(c), i),
                  Connect(loc, exp(c))
                  EmptyCommand())

defn expand-command-multi-connects (c:Command) :
   match(c) :
      (c:ConnectMany) : convert-connect-many(c)
      (c:ManyConnect) : convert-connect-many(c)
      (c) : map(expand-command-multi-connects, c)

defn expand-multi-connects (c:Circuit) :
   val modules* =
      for m in modules(c) map :
         val body* = expand-command-multi-connects(body(m))
         Module(name(m), ports(m), body*)
   Circuit(modules*, main(c))

;================ EXPAND WHENS =============================
definterface SymbolicValue
defstruct ImmediateValue <: SymbolicValue :
  imm: Immediate
defstruct WhenValue <: SymbolicValue :
  pred: Immediate
  conseq: SymbolicValue
  alt: SymbolicValue
defstruct VoidValue <: SymbolicValue

defn eqv? (v1:SymbolicValue, v2:SymbolicValue) :
   match(v1, v2) :
      (v1:ImmediateValue, v2:ImmediateValue) :
         eqv?(imm(v1), imm(v2))
      (v1:WhenValue, v2:WhenValue) :
         eqv?(pred(v1), pred(v2)) and
         eqv?(conseq(v1), conseq(v2)) and
         eqv?(alt(v1), alt(v2))
      (v1:VoidValue, v2:VoidValue) : true
      (v1, v2) : false

defn merge-env (pred:Immediate,
                con-env: List<KeyValue<Immediate,SymbolicValue>>,
                alt-env: List<KeyValue<Immediate,SymbolicValue>>) :
   val env = Vector<KeyValue<Immediate, SymbolicValue>>()
   for entry in con-env do :
      if lookup(env, key(entry)) == false :
         match(lookup(alt-env, key(entry))) :
            (sv:SymbolicValue) :
               if eqv?(sv, value(entry)) : add(env, entry)
               else : add(env, key(entry) => WhenValue(pred, value(entry), sv))
            (f:False) : add(env, entry)
   for entry in alt-env do :
      if lookup(env, key(entry)) == false :
         add(env, entry)
   to-list(env)

defn simplify-env (env: List<KeyValue<Immediate,SymbolicValue>>) :
   val seen = Vector<Immediate>()
   defn seen? (i:Immediate) :
      find(eqv?{i, _}, seen) != false

   to-list $
   for entry in env filter :
      if not seen?(key(entry)) :
         add(seen, key(entry))
         true

defn expand-whens (c:Command,
                   env:List<KeyValue<Immediate,SymbolicValue>>) :
   val cs = Vector<Command>()
   defn eval (c:Command, env:List<KeyValue<Immediate,SymbolicValue>>) ->
              List<KeyValue<Immediate,SymbolicValue>> :
      match(c) :
         (c:DefInt|DefSInt|DoPrim) :
            add(cs, c)
            env
         (c:DefWire) :
            add(cs, c)
            List(Ref(name(c)) => VoidValue(), env)
         (c:DefRegister) :
            add(cs, c)
            val ref = Ref(name(c))
            List(ref => ImmediateValue(ref), env)
         (c:DefInstance) :
            add(cs, c)
            val module-type = type(module(c)) as BundleType
            val in-ports =
               for p in ports(module-type) filter :
                  direction(p) == INPUT
            to-list{concat(_, env)} $
            for p in in-ports stream :
               val ref = Field(Ref(name(c)), name(p))
               ref => VoidValue()
         (c:DefMemory) :
            add(cs, c)
            env
         (c:DefAccessor) :
            add(cs, c)
            if direction(c) == INPUT :
               List(Ref(name(c)) => VoidValue(), env)
            else :
               env
         (c:Conditionally) :
            val con-env = eval(conseq(c), env)
            val alt-env = eval(alt(c), env)
            merge-env(pred(c), con-env, alt-env)
         (c:Begin) :
            var current-env:List<KeyValue<Immediate,SymbolicValue>> = env
            for c in body(c) do :
               current-env = eval(c, current-env)
            current-env
         (c:Connect) :
            List(loc(c) => ImmediateValue(exp(c)), env)
         (c:EmptyCommand) :
            env

   defn convert-symbolic (sv:SymbolicValue) :
      match(sv) :
         (sv:VoidValue) :
            throw $ PassException $ string-join $
            ["Uninitialized Connection."]
         (sv:ImmediateValue) :
            imm(sv)
         (sv:WhenValue) :
            val name = gensym()
            add{cs, _} $
            DoPrim(name, MULTIPLEX-OP,
                   list(pred(sv),
                        convert-symbolic(conseq(sv)),
                        convert-symbolic(alt(sv))))
            Ref(name)

   val env* = simplify-env(eval(c, env))
   for entry in env* do :
      add(cs, Connect(key(entry), convert-symbolic(value(entry))))
   Begin(to-list(cs))

defn expand-whens (m:Module) :
   val env = let :
      val out-ports = filter({direction(_) == OUTPUT}, ports(m))
      to-list $
      for p in out-ports stream :
         val ref = Field(Ref('this), name(p))
         ref => VoidValue()
   val body* = expand-whens(body(m), env)
   Module(name(m), ports(m), body*)

defn expand-whens (c:Circuit) :
   val modules* = map(expand-whens, modules(c))
   Circuit(modules*, main(c))


;============== WIDTH CONSTRAINTS ==========================
defn typewidth (t:Type) :
   match(t) :
      (t:IntType) : width(t)
      (t:SIntType) : width(t)
      (t) : error $ string-join $
            [t " has no width field."]

defn assoc-width (t:Type, w:Width) :
   match(t) :
      (t:IntType) : IntType(w)
      (t:SIntType) : SIntType(w)
      (t) : error $ string-join $
            [t " has no width field."]

defn copy-width (t1:Type, t2:Type) :
   match(t1, t2) :
      (t1:IntType, t2:IntType) : t2
      (t1:SIntType, t2:SIntType) : t2
      (t1:BundleType, t2:BundleType) :
         if map(name, ports(t1)) == map(name, ports(t2)) :
            BundleType $
            for (p1 in ports(t1), p2 in ports(t2)) map :
               Port(name(p1), direction(p1), copy-width(type(p1), type(p2)))
         else :
            error $ string-join $
            ["Types " t1 " and " t2 " are not equivalent."]

defn add-width-var? (t:Type) :
   match(typewidth(t)) :
      (w:UnknownWidth) : assoc-width(t, WidthVar(gensym()))
      (w) : t

defn make-width-constraints (c:Command, e: List<KeyValue<Symbol, Type>>, cs: Vector<WConstraint>) :
   ;Make table for types
   val types = HashTable<Symbol,Type>(symbol-hash)
   for entry in e do :
      types[key(entry)] = value(entry)

   ;Fill in immediate with widths
   defn imm-width (i:Immediate) :
      match(i) :
         (i:Ref) :
            val type* = copy-width(type(i), types[name(i)])
            Ref(name(i), direction(i), type*)
         (i:Field) :
            val imm* = imm-width(imm(i))
            val port-type = type(port) where :
               val t = type(imm*) as BundleType
               val port = lookup-port!(ports(t), name(i))
            val type* = copy-width(type(i), port-type)
            Field(imm*, name(i), direction(i), type*)

   ;Calculate new width objects
   defn width-exp (w:Width) :
      match(w) :
         (w:WidthVar) : EVar(name(w))
         (w:IntWidth) : ELit(value(w))
   defn width-op (f: (Exp, Exp) -> Exp, a:Width, b:Width) :
      val name = gensym()
      add(cs, WidthEqual(name, f(width-exp(a), width-exp(b))))
      WidthVar(name)
   defn width-plus (a:Width, b:Width) : width-op(EPlus, a, b)
   defn width-minus (a:Width, b:Width) : width-op(EMinus, a, b)
   defn width-max (a:Width, b:Width) : width-op(EMax, a, b)
   defn width-max-inc (a:Width, b:Width) :
      width-op{_, a, b} $ fn (a, b) :
         EPlus(ELit(1), EMax(a, b))

   ;Compute the resulting width of a primop
   defn primop-type (op:PrimOp, types: List<Type>) -> Type :
      defn Type (i: Int) -> (Width) -> Type :
         match(types[i]) :
            (t:IntType) : IntType
            (t:SIntType) : SIntType
      val widths = map(typewidth, types)   
      switch {op == _} :
         ADD-OP : Type(0)(width-max-inc(widths[0], widths[1]))
         MINUS-OP : Type(0)(width-max-inc(widths[0], widths[1]))
         TIMES-OP : Type(0)(width-plus(widths[0], widths[1]))
         DIVIDE-OP : Type(0)(width-minus(widths[0], widths[1]))
         MOD-OP : Type(0)(widths[1])
         SHIFT-LEFT-OP : error("Not yet supported.")
         SHIFT-RIGHT-OP : error("Not yet supported.")
         BIT-AND-OP : IntType(width-max(widths[0], widths[1]))
         BIT-OR-OP : IntType(width-max(widths[0], widths[1]))
         BIT-XOR-OP : IntType(width-max(widths[0], widths[1]))
         CONCAT-OP : IntType(width-plus(widths[0], widths[1]))
         BIT-SELECT-OP : IntType(IntWidth(1))
         MULTIPLEX-OP : Type(1)(width-max(widths[1], widths[2]))
         LESS-OP : IntType(IntWidth(1))
         LESS-EQ-OP : IntType(IntWidth(1))
         GREATER-OP : IntType(IntWidth(1))
         GREATER-EQ-OP : IntType(IntWidth(1))
         EQUAL-OP : IntType(IntWidth(1))

   ;Compute the width of literals
   defn min-int-width (x:Int) :
      if x == 0 :
         1
      else :
         var n:Int = 1
         var l:Int = 0
         while n <= x :
            l = l + 1
            n = n * 2
         l
   defn min-sint-width (x:Int) :
      error("Signed numbers: not yet supported.")
         
   ;Fill in commands with widths
   defn loop (c:Command) -> Command :
      match(c) :
         (c:DefInt) :
            types[name(c)] = IntType $
               IntWidth(min-int-width(value(c)))
            c
         (c:DefSInt) :
            types[name(c)] = SIntType $
               IntWidth(min-sint-width(value(c)))
            c
         (c:DoPrim) :
            val args* = map(imm-width, args(c))
            types[name(c)] = primop-type(op(c), map(type, args*))
            DoPrim(name(c), op(c), args*)
         (c:DefWire) :
            val type* = add-width-var?(type(c))
            types[name(c)] = type*
            DefWire(name(c), type*)
         (c:DefRegister) :
            val type* = add-width-var?(type(c))
            types[name(c)] = type*
            DefRegister(name(c), type*)
         (c:DefInstance) :
            val module* = imm-width(module(c)) as Ref
            types[name(c)] = type(module*)
            DefInstance(name(c), module*)
         (c:DefMemory) :
            val type* = add-width-var?(type(c))
            types[name(c)] = type*
            DefMemory(name(c), type*, size(c))
         (c:DefAccessor) :
            val source* = imm-width(source(c)) as Ref
            val index* = imm-width(index(c))
            types[name(c)] = type(source*)
            DefAccessor(name(c), source*, direction(c), index*)
         (c:Connect) :
            val loc* = imm-width(loc(c))
            val exp* = imm-width(exp(c))
            match(typewidth(type(loc*))) :
               (w:WidthVar) :
                  val exp-width = width-exp(typewidth(type(exp*)))
                  add(cs, WidthGreater(name(w), exp-width))
               (w) : false
            Connect(loc*, exp*)   
         (c) :
            map(loop, c)

   ;Call on command
   loop(c)


defn make-width-constraints (m:Module, e:List<KeyValue<Symbol, Type>>, cs:Vector<WConstraint>) :
   val env = List(
      'this => lookup!(e, name(m))
      e)
   val body = make-width-constraints(body(m), env, cs)
   Module(name(m), ports(m), body)


defn make-width-constraints (c:Circuit, cs:Vector<WConstraint>) :
   val modules* =
      for m in modules(c) map :
         val ports* = 
            for p in ports(m) map :
               val type* = add-width-var?(type(p))
               Port(name(p), direction(p), type*)
         Module(name(m), ports*, body(m))
   val env =
      for m in modules* map :
         name(m) => BundleType(ports(m))
         
   Circuit{_, main(c)} $
   map(make-width-constraints{_, env, cs}, modules*)

;================= FILL WIDTHS =============================
defn fill-widths (t:Type, get-width: (Symbol) -> Width) :
   match(t) :
      (t:IntType) :
         if width(t) typeof WidthVar :
            val name = name(width(t) as WidthVar)
            IntType(get-width(name))            
         else : t
      (t:SIntType) :
         if width(t) typeof WidthVar :
            val name = name(width(t) as WidthVar)
            IntType(get-width(name))
         else : t
      (t:BundleType) :
         BundleType $ map(fill-widths{_, get-width}, ports(t))
         
defn fill-widths (p:Port, get-width: (Symbol) -> Width) :
   Port(name(p), direction(p), fill-widths(type(p), get-width))
   
defn fill-widths (i:Immediate, get-width: (Symbol) -> Width) :
   match(i) :
      (i:Ref) :
         Ref(name(i), direction(i), fill-widths(type(i), get-width))
      (i:Field) :
         val imm* = fill-widths(imm(i), get-width)
         Field(imm*, name(i), direction(i), fill-widths(type(i), get-width))

defn fill-widths (c:Command, get-width: (Symbol) -> Width) -> Command :
   match(c) :
      (c:DefWire) : DefWire(name(c), fill-widths(type(c), get-width))
      (c:DefRegister) : DefRegister(name(c), fill-widths(type(c), get-width))
      (c:DefMemory) : DefMemory(name(c), fill-widths(type(c), get-width), size(c))
      (c) :
         val c* = map(fill-widths{_ as Immediate, get-width}, c)
         map(fill-widths{_ as Command, get-width}, c*)

defn fill-widths (m:Module, get-width: (Symbol) -> Width) :
   Module(name(m),
          map(fill-widths{_, get-width}, ports(m)),
          fill-widths(body(m), get-width))

defn fill-widths (c:Circuit, solved: Streamable<WidthEqual>) :
   ;Construct get-width function
   val table = HashTable<Symbol,Width>(symbol-hash)
   for eqn in solved do :
      table[name(eqn)] = IntWidth(width(value(eqn) as ELit))
   defn get-width (n:Symbol) :
      get?(table, n, UnknownWidth())

   val modules* = map(fill-widths{_, get-width}, modules(c))
   Circuit(modules*, main(c))

;================= INFER WIDTHS ============================
defn infer-widths (c:Circuit) :
   var c*:Circuit = c
   c* = infer-types(c*)
   val cs = Vector<WConstraint>()
   c* = make-width-constraints(c*, cs)
   val solved = solve-widths(cs)
   fill-widths(c*, solved)

;============= DRIVER ======================================
public defn run-passes (c: Circuit) :
  var c*:Circuit = c
  check-duplicates(c*)
  c* = make-explicit-reset(c*)
  c* = initialize-registers(c*)
  c* = infer-types(c*)
  c* = infer-accessor-dirs(c*)
  c* = expand-vecs(c*)
  c* = infer-types(c*)
  c* = expand-circuit-bundles(c*)
  c* = cleanup-circuit(c*)
  c* = expand-multi-connects(c*)
  c* = expand-whens(c*)
  c* = infer-widths(c*)


;  c* = expand-whens(c)
  c*
