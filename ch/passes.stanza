defpackage chipper.passes:
  import core
  import verse
  import chipper.ir

;============== EXCEPTIONS =================================
defclass PassException <: Exception
defn PassException (msg:String) :
  new PassException :
    defmethod print (o:OutputStream, this) :
      print(o, msg)


;============ CHECK IF NAMES ARE UNIQUE ====================
defn check-duplicate-symbols (names: Streamable<Symbol>, msg: String) :
  val dict = HashTable<Symbol, True>(symbol-hash)
  for name in names do:
    if key?(dict, name):
      throw $ PassException $ string-join $
      [msg ": " name]
    else:
      dict[name] = true

defn check-duplicates (t: Type) :
  match(t) :
    (t:BundleType) :
      val names = map(name, ports(t))
      check-duplicate-symbols{names, string-join(_)} $
        ["Duplicate port name in bundle "]
      do(check-duplicates{type(_)}, ports(t))
    (t) : false

defn check-duplicates (c: Command) :
  match(c) :
    (c:DefWire) : check-duplicates(type(c))
    (c:DefRegister) : check-duplicates(type(c))
    (c:DefMemory) : check-duplicates(type(c))
    (c:DefVector) : check-duplicates(type(c))
    (c) : do(check-duplicates, children(c))  

defn defined-names (c: Command) :
  generate<Symbol> :
    loop(c) where :
      defn loop (c:Command) :
        match(c) :
          (c:Command&HasName) : yield(name(c))
          (c) : do(loop, children(c))

defn check-duplicates (m: Module):
  ;Check all duplicate names in all types in all ports and body
  do(check-duplicates{type(_)}, ports(m))
  check-duplicates(body(m))

  ;Check all names defined in module
  val names = concat(stream(name, ports(m)),
                     defined-names(body(m)))
  check-duplicate-symbols{names, string-join(_)} $
    ["Duplicate definition name in module " name(m)]

defn check-duplicates (c: Circuit) :
  ;Check all duplicate names in all modules
  do(check-duplicates, modules(c))

  ;Check all defined modules
  val names = stream(name, modules(c))
  check-duplicate-symbols(names, "Duplicate module name")



;============= INFER TYPES FOR ALL IMMEDIATES ==============
defn lookup-port (ports: Streamable<Port>, port-name: Symbol) :
  for port in ports find :
    name(port) == port-name

defn lookup-port! (ports: Streamable<Port>, port-name: Symbol) :
  match(lookup-port(ports, port-name)) :
    (p:Port) : p
    (p:False) :
      error $ string-join $
        ["No port found with name: " port-name "."]           

defn infer (i: Immediate, e: List<KeyValue<Symbol, Type>>) -> Immediate :
  match(i) :
    (r:Ref) :
      val type = lookup!(e, name(r))
      Ref(name(r), type)
    (f:Field) :
      val imm* = infer(imm(f), e)
      val type = match(type(imm*)) :
                   (t:BundleType) :
                     match(lookup-port(ports(t), name(f))) :
                       (p:Port) : type(p)
                       (p) : type(f)
                   (t) : type(f)
      Field(imm*, name(f), type)             

defn infer (p:PrimOp, arg-types: List<Type>) -> Type :
  IntType(UnknownWidth()) 

defn infer (c:Command, e: List<KeyValue<Symbol,Type>>) -> [Command, List<KeyValue<Symbol,Type>>] :
  defn push-e (name: Symbol, t: Type) : List(name => t, e)
  match(c) :
    (c:DefInt|DefSInt) :
      [c, push-e(name(c), IntType(UnknownWidth()))]
    (c:DefWire) :
      val value* = infer(value(c) as Immediate, e) when value(c) != false
      [DefWire(name(c), type(c), value*), push-e(name(c), type(c))]
    (c:DefRegister) :
      val value* = infer(value(c) as Immediate, e) when value(c) != false
      val type* = BundleType $ to-list $ [
                    Port('data, OUTPUT, type(c))
                    Port('init, INPUT, type(c))]
      [DefRegister(name(c), type(c), value*), push-e(name(c), type*)]
    (c:DefMemory) :
      [DefMemory(name(c), type(c), size(c)), push-e(name(c), type(c))]
    (c:DefVector) :
      val args* = map({infer(_, e)}, args(c))
      [DefVector(name(c), type(c), args*), push-e(name(c), type(c))]
    (c:DefAccessor) :
      val type = lookup!(e, source(c))
      val index* = infer(index(c), e)
      [DefAccessor(name(c), source(c), direction(c), index*), push-e(name(c), type)]
    (c:DefInstance) :
      val type = lookup!(e, module(c))
      [c, push-e(name(c), type)]
    (c:Conditionally) :
      val pred* = infer(pred(c), e)
      val [con*, con-e] = infer(conseq(c), e)
      val [alt*, alt-e] = infer(alt(c), e)
      [Conditionally(pred*, con*, alt*), e]
    (c:Begin) :        
      var current-e: List<KeyValue<Symbol,Type>> = e
      val body* = for c in body(c) map :
        val [c*, e] = infer(c, current-e)
        current-e = e
        c*
      [Begin(body*), current-e]   
    (c:Connect) :
      [Connect(infer(loc(c), e), infer(exp(c), e)), e]
    (c:DoPrim) :
      val args* = map(infer{_, e}, args(c))
      val type* = infer(op(c), map(type, args*))
      [DoPrim(name(c), op(c), args*), push-e(name(c), type*)]
    (c:Select) :
      val idx* = infer(idx(c), e)      
      val args* = map(infer{_, e}, args(c))
      val type* = type(args(c)[0])
      [Select(name(c), idx*, args*), push-e(name(c), type*)]        
    (c:SelectivelyConnect) :
      val idx* = infer(idx(c), e)
      val locs* = map(infer{_, e}, locs(c))
      val exp* = infer(exp(c), e)
      [SelectivelyConnect(idx*, locs*, exp*), e]
    (c:EmptyCommand) : [c, e]          

defn infer (m: Module, e: List<KeyValue<Symbol,Type>>) -> Module :
  val port-type = let :
    val type = lookup!(e, name(m)) as BundleType
    BundleType $ map(flip, ports(type))
  val m-env = List('this => port-type, e)
  val [body*, env*] = infer(body(m), m-env)
  Module(name(m), ports(m), body*)

defn infer-types (c: Circuit) -> Circuit:
  val env =
    for m in modules(c) map :
      name(m) => BundleType $
                   List(Port('reset, INPUT, IntType(IntWidth(1))),
                        ports(m))
  val modules* = map(infer{_, env}, modules(c))                      
  Circuit(modules*, main(c))  


;============== EXPAND VECS ================================
defn* root-ref (i:Immediate) :
   match(i) :
      (f:Field) : root-ref(imm(f))
      (r:Ref) : r

defn replace-root (i:Immediate, root:Immediate) :
   match(i) :
      (r:Ref) : root
      (f:Field) :
         Field{_, name(f), type(f)} $
         replace-root(imm(f), root)

defn lookup-accessor (e: List<KeyValue<Symbol, DefVector|DefAccessor>>, exp: Immediate) :
   val ref = root-ref(exp)
   match(lookup(e, name(ref))) :
     (acc:DefAccessor) :
       val vec = lookup!(e, source(acc)) as DefVector
       val args* = map(replace-root{exp, _}, args(vec))
       [index(acc), args*]
     (x) :
       false

defn expand-imm (imm: Immediate,
                 e: List<KeyValue<Symbol, DefVector|DefAccessor>>,
                 cs:Vector<Command>) :
  match(lookup-accessor(e, imm)) :
    ([idx args]:[Immediate, List<Immediate>]) :
      val c = Select(gensym(), idx, args)
      add(cs, c)
      Ref(name(c), type(imm))
    (f:False) :
      imm

defn expand-connect (c: Connect,
                     e: List<KeyValue<Symbol, DefVector|DefAccessor>>,
                     cs: Vector<Command>) :
  val exp* = expand-imm(exp(c), e, cs)  
  match(lookup-accessor(e, loc(c))) :
    ([idx args]:[Immediate, List<Immediate>]) :
      SelectivelyConnect(idx, args, exp*)
    (f:False) :
      Connect(loc(c), exp*)                       

public defn expand-vecs (c: Command,
                         e: List<KeyValue<Symbol, DefVector|DefAccessor>>) ->
                        [Command, List<KeyValue<Symbol, DefVector|DefAccessor>>] :
  val cs = Vector<Command>()
  val env = 
    if c typeof Connect :
      add(cs, expand-connect(c as Connect, e, cs))
      e
    else :
      match(map(expand-imm{_, e, cs}, c)) :
        (c:DefVector) :
          List(name(c) => c, e)
        (c:DefAccessor) :
          if lookup(e, source(c)) != false :
            List(name(c) => c, e)
          else :
            add(cs, c)
            e
        (c:Begin) :
          var current-e: List<KeyValue<Symbol,DefVector|DefAccessor>> = e
          for c in body(c) do :
            val [c*, e*] = expand-vecs(c, current-e)
            current-e = e*
            add(cs, c*)
          current-e
        (c:Conditionally) :
          val [con*, con-e] = expand-vecs(conseq(c), e)
          val [alt*, alt-e] = expand-vecs(alt(c), e)
          add(cs, Conditionally(pred(c), con*, alt*))
          e
        (c) :
          add(cs, c)
          e

  switch {length(cs) == _} :
    0 : [EmptyCommand(), env]
    1 : [cs[0], env]
    else : [Begin(to-list(cs)), env]        

public defn expand-vecs (c: Circuit) :
  Circuit{_, main(c)} $
  for m in modules(c) map :
    val [body*, env] = expand-vecs(body(m), List())
    Module(name(m), ports(m), body*)      



;========= INFER DIRECTIONS OF MEMORY PORTS ================
defn find-accessor-uses (c:Command) :
  to-list $ generate<KeyValue<Symbol,Direction>> :
    val accessors = Vector<Symbol>()
    defn find-use (imm:Immediate, dir:Direction) :
      val root = root-ref(imm)
      if contains?(accessors, name(root)) :
        yield(name(root) => dir)
      imm  
        
    defn find-use (c:Command) -> ? :
      match(c) :
        (c:DefAccessor) :
          add(accessors, name(c))
          find-use(index(c), OUTPUT)
        (c:Connect) :
          find-use(loc(c), INPUT)
          find-use(exp(c), OUTPUT)
        (c) :
          map(find-use{_, OUTPUT}, c) ;Find uses in immediates
          do(find-use, children(c)) ;Find uses in subcommands

    find-use(c)

defn fold-accessor-uses (uses: List<KeyValue<Symbol,Direction>>) :
  val table = HashTable<Symbol,Direction>(symbol-hash)
  for use in uses do :
    match(get?(table, key(use), false)) :
      (d:Direction) :
        if d != value(use) :
          throw $ PassException $ string-join $
          ["Accessor " key(use) " is used both as an INPUT and an OUTPUT."]          
      (f:False) :
        table[key(use)] = value(use)
  to-list(table)      

defn fill-accessor-dirs (c:Command, uses:List<KeyValue<Symbol,Direction>>) -> Command :
  match(c) :
    (c:DefAccessor) :
      val dir =
        match(lookup(uses, name(c))) :
          (d:Direction) : d
          (d:False) : throw $ PassException $ string-join $
                      ["Accessor " name(c) " is never used. Unable to infer direction."]
      DefAccessor(name(c), source(c), dir, index(c))
    (c:Command) :
      map(fill-accessor-dirs{_, uses}, c)

defn infer-accessor-dirs (c:Circuit) :
  val modules* =
    for m in modules(c) map :
      val uses = fold-accessor-uses(find-accessor-uses(body(m)))
      val body* = fill-accessor-dirs(body(m), uses)
      Module(name(m), ports(m), body*)
  Circuit(modules*, main(c))


;============= DRIVER ======================================
public defn run-passes (c: Circuit) :
  var c*:Circuit = c
  check-duplicates(c*)
  c* = infer-types(c*)
  c* = expand-vecs(c*)
  c* = infer-accessor-dirs(c*)
  c*
