defpackage chipper.passes:
  import core
  import verse
  import chipper.ir

;============== EXCEPTIONS =================================
defclass PassException <: Exception
defn PassException (msg:String) :
  new PassException :
    defmethod print (o:OutputStream, this) :
      print(o, msg)


;============ CHECK IF NAMES ARE UNIQUE ====================
defn check-duplicate-symbols (names: Streamable<Symbol>, msg: String) :
  val dict = HashTable<Symbol, True>(symbol-hash)
  for name in names do:
    if key?(dict, name):
      throw $ PassException $ string-join $
      [msg ": " name]
    else:
      dict[name] = true

defn check-duplicates (t: Type) :
  match(t) :
    (t:BundleType) :
      val names = map(name, ports(t))
      check-duplicate-symbols{names, string-join(_)} $
        ["Duplicate port name in bundle "]
      do(check-duplicates{type(_)}, ports(t))
    (t) : false

defn check-duplicates (c: Command) :
  match(c) :
    (c:DefWire) : check-duplicates(type(c))
    (c:DefRegister) : check-duplicates(type(c))
    (c:DefMemory) : check-duplicates(type(c))
    (c:DefVector) : check-duplicates(type(c))
    (c) : do(check-duplicates, children(c))  

defn defined-names (c: Command) :
  generate<Symbol> :
    loop(c) where :
      defn loop (c:Command) :
        match(c) :
          (c:Command&HasName) : yield(name(c))
          (c) : do(loop, children(c))

defn check-duplicates (m: Module):
  ;Check all duplicate names in all types in all ports and body
  do(check-duplicates{type(_)}, ports(m))
  check-duplicates(body(m))

  ;Check all names defined in module
  val names = concat(stream(name, ports(m)),
                     defined-names(body(m)))
  check-duplicate-symbols{names, string-join(_)} $
    ["Duplicate definition name in module " name(m)]

defn check-duplicates (c: Circuit) :
  ;Check all duplicate names in all modules
  do(check-duplicates, modules(c))

  ;Check all defined modules
  val names = stream(name, modules(c))
  check-duplicate-symbols(names, "Duplicate module name")



;============= INFER TYPES FOR ALL IMMEDIATES ==============
defn lookup-port (ports: Streamable<Port>, port-name: Symbol) :
  for port in ports find :
    name(port) == port-name

defn lookup-port! (ports: Streamable<Port>, port-name: Symbol) :
  match(lookup-port(ports, port-name)) :
    (p:Port) : p
    (p:False) :
      error $ string-join $
        ["No port found with name: " port-name "."]           

defn infer (i: Immediate, e: List<KeyValue<Symbol, Type>>) -> Immediate :
  match(i) :
    (r:Ref) :
      val type = lookup!(e, name(r))
      Ref(name(r), type)
    (f:Field) :
      val imm* = infer(imm(f), e)
      val type = match(type(imm*)) :
                   (t:BundleType) :
                     match(lookup-port(ports(t), name(f))) :
                       (p:Port) : type(p)
                       (p) : type(f)
                   (t) : type(f)
      Field(imm*, name(f), type)             

defn infer (p:PrimOp, arg-types: List<Type>) -> Type :
  IntType(UnknownWidth()) 

defn infer (c:Command, e: List<KeyValue<Symbol,Type>>) -> [Command, List<KeyValue<Symbol,Type>>] :
  defn push-e (name: Symbol, t: Type) : List(name => t, e)
  match(c) :
    (c:DefInt|DefSInt) :
      [c, push-e(name(c), IntType(UnknownWidth()))]
    (c:DefWire) :
      [c, push-e(name(c), type(c))]
    (c:DefRegister) :
      val type* = BundleType $ to-list $ [
                    Port('data, OUTPUT, type(c))
                    Port('init, INPUT, type(c))]
      [c, push-e(name(c), type*)]
    (c:DefMemory) :
      [DefMemory(name(c), type(c), size(c)), push-e(name(c), type(c))]
    (c:DefVector) :
      val args* = map({infer(_, e)}, args(c))
      [DefVector(name(c), type(c), args*), push-e(name(c), type(c))]
    (c:DefAccessor) :
      val type = lookup!(e, source(c))
      val index* = infer(index(c), e)
      [DefAccessor(name(c), source(c), direction(c), index*), push-e(name(c), type)]
    (c:DefInstance) :
      val type = lookup!(e, module(c))
      [c, push-e(name(c), type)]
    (c:Conditionally) :
      val pred* = infer(pred(c), e)
      val [con*, con-e] = infer(conseq(c), e)
      val [alt*, alt-e] = infer(alt(c), e)
      [Conditionally(pred*, con*, alt*), e]
    (c:Begin) :        
      var current-e: List<KeyValue<Symbol,Type>> = e
      val body* = for c in body(c) map :
        val [c*, e] = infer(c, current-e)
        current-e = e
        c*
      [Begin(body*), current-e]   
    (c:Connect) :
      [Connect(infer(loc(c), e), infer(exp(c), e)), e]
    (c:DoPrim) :
      val args* = map(infer{_, e}, args(c))
      val type* = infer(op(c), map(type, args*))
      [DoPrim(name(c), op(c), args*), push-e(name(c), type*)]
    (c:Select) :
      val idx* = infer(idx(c), e)      
      val args* = map(infer{_, e}, args(c))
      val type* = type(args(c)[0])
      [Select(name(c), idx*, args*), push-e(name(c), type*)]        
    (c:SelectivelyConnect) :
      val idx* = infer(idx(c), e)
      val locs* = map(infer{_, e}, locs(c))
      val exp* = infer(exp(c), e)
      [SelectivelyConnect(idx*, locs*, exp*), e]
    (c:EmptyCommand) : [c, e]          

defn infer (m: Module, e: List<KeyValue<Symbol,Type>>) -> Module :
  val port-type = let :
    val type = lookup!(e, name(m)) as BundleType
    BundleType $ map(flip, ports(type))
  val m-env = List('this => port-type, e)
  val [body*, env*] = infer(body(m), m-env)
  Module(name(m), ports(m), body*)

defn infer-types (c: Circuit) -> Circuit:
  val env =
    for m in modules(c) map :
      name(m) => BundleType $
                   List(Port('reset, INPUT, IntType(IntWidth(1))),
                        ports(m))
  val modules* = map(infer{_, env}, modules(c))                      
  Circuit(modules*, main(c))  


;============== EXPAND VECS ================================
defn* root-ref (i:Immediate) :
   match(i) :
      (f:Field) : root-ref(imm(f))
      (r:Ref) : r

defn replace-root (i:Immediate, root:Immediate) :
   match(i) :
      (r:Ref) : root
      (f:Field) :
         Field{_, name(f), type(f)} $
         replace-root(imm(f), root)

defn lookup-accessor (e: List<KeyValue<Symbol, DefVector|DefAccessor>>, exp: Immediate) :
  val ref = root-ref(exp)
  match(lookup(e, name(ref))) :
    (acc:DefAccessor) :
      val vec = lookup!(e, source(acc)) as DefVector
      val args* = map(replace-root{exp, _}, args(vec))
      [index(acc), args*]
    (x) :
      false

defn expand-imm (imm: Immediate,
                 e: List<KeyValue<Symbol, DefVector|DefAccessor>>,
                 cs:Vector<Command>) :
  match(lookup-accessor(e, imm)) :
    ([idx args]:[Immediate, List<Immediate>]) :
      val c = Select(gensym(), idx, args)
      add(cs, c)
      Ref(name(c), type(imm))
    (f:False) :
      imm

defn expand-connect (c: Connect,
                     e: List<KeyValue<Symbol, DefVector|DefAccessor>>,
                     cs: Vector<Command>) :
  val exp* = expand-imm(exp(c), e, cs)  
  match(lookup-accessor(e, loc(c))) :
    ([idx args]:[Immediate, List<Immediate>]) :
      SelectivelyConnect(idx, args, exp*)
    (f:False) :
      Connect(loc(c), exp*)                       

public defn expand-vecs (c: Command,
                         e: List<KeyValue<Symbol, DefVector|DefAccessor>>) ->
                        [Command, List<KeyValue<Symbol, DefVector|DefAccessor>>] :
  val cs = Vector<Command>()
  val env = 
    if c typeof Connect :
      add(cs, expand-connect(c as Connect, e, cs))
      e
    else :
      match(map(expand-imm{_, e, cs}, c)) :
        (c:DefVector) :
          List(name(c) => c, e)
        (c:DefAccessor) :
          if lookup(e, source(c)) != false :
            List(name(c) => c, e)
          else :
            add(cs, c)
            e
        (c:Begin) :
          var current-e: List<KeyValue<Symbol,DefVector|DefAccessor>> = e
          for c in body(c) do :
            val [c*, e*] = expand-vecs(c, current-e)
            current-e = e*
            add(cs, c*)
          current-e
        (c:Conditionally) :
          val [con*, con-e] = expand-vecs(conseq(c), e)
          val [alt*, alt-e] = expand-vecs(alt(c), e)
          add(cs, Conditionally(pred(c), con*, alt*))
          e
        (c) :
          add(cs, c)
          e

  switch {length(cs) == _} :
    0 : [EmptyCommand(), env]
    1 : [cs[0], env]
    else : [Begin(to-list(cs)), env]        

public defn expand-vecs (c: Circuit) :
  Circuit{_, main(c)} $
  for m in modules(c) map :
    val [body*, env] = expand-vecs(body(m), List())
    Module(name(m), ports(m), body*)      



;========= INFER DIRECTIONS OF MEMORY PORTS ================
defn find-accessor-uses (c:Command) :
  to-list $ generate<KeyValue<Symbol,Direction>> :
    val accessors = Vector<Symbol>()
    defn find-use (imm:Immediate, dir:Direction) :
      val root = root-ref(imm)
      if contains?(accessors, name(root)) :
        yield(name(root) => dir)
      imm  
        
    defn find-use (c:Command) -> ? :
      match(c) :
        (c:DefAccessor) :
          add(accessors, name(c))
          find-use(index(c), OUTPUT)
        (c:Connect) :
          find-use(loc(c), INPUT)
          find-use(exp(c), OUTPUT)
        (c) :
          map(find-use{_, OUTPUT}, c) ;Find uses in immediates
          do(find-use, children(c)) ;Find uses in subcommands

    find-use(c)

defn fold-accessor-uses (uses: List<KeyValue<Symbol,Direction>>) :
  val table = HashTable<Symbol,Direction>(symbol-hash)
  for use in uses do :
    match(get?(table, key(use), false)) :
      (d:Direction) :
        if d != value(use) :
          throw $ PassException $ string-join $
          ["Accessor " key(use) " is used both as an INPUT and an OUTPUT."]          
      (f:False) :
        table[key(use)] = value(use)
  to-list(table)      

defn fill-accessor-dirs (c:Command, uses:List<KeyValue<Symbol,Direction>>) -> Command :
  match(c) :
    (c:DefAccessor) :
      val dir =
        match(lookup(uses, name(c))) :
          (d:Direction) : d
          (d:False) : throw $ PassException $ string-join $
                      ["Accessor " name(c) " is never used. Unable to infer direction."]
      DefAccessor(name(c), source(c), dir, index(c))
    (c:Command) :
      map(fill-accessor-dirs{_, uses}, c)

defn infer-accessor-dirs (c:Circuit) :
  val modules* =
    for m in modules(c) map :
      val uses = fold-accessor-uses(find-accessor-uses(body(m)))
      val body* = fill-accessor-dirs(body(m), uses)
      Module(name(m), ports(m), body*)
  Circuit(modules*, main(c))


;================ EXPAND WHENS =============================
definterface SymbolicValue 
defstruct ImmediateValue <: SymbolicValue :
  imm: Immediate
defstruct WhenValue <: SymbolicValue :
  pred: Immediate
  conseq: SymbolicValue
  alt: SymbolicValue
defstruct VoidValue <: SymbolicValue

defn eqv? (v1:SymbolicValue, v2:SymbolicValue) :
   match(v1, v2) :
      (v1:ImmediateValue, v2:ImmediateValue) :
         eqv?(imm(v1), imm(v2))
      (v1:WhenValue, v2:WhenValue) :
         eqv?(pred(v1), pred(v2)) and
         eqv?(conseq(v1), conseq(v2)) and
         eqv?(alt(v1), alt(v2))
      (v1:VoidValue, v2:VoidValue) : true
      (v1, v2) : false

defn merge-env (pred:Immediate,
                con-env: List<KeyValue<Immediate,SymbolicValue>>,
                alt-env: List<KeyValue<Immediate,SymbolicValue>>) :
   defn lookup (e: Streamable<KeyValue<Immediate,SymbolicValue>>, i:Immediate) :
      for entry in e search :
         if eqv?(key(entry), i) :
            value(entry)
         
   val env = Vector<KeyValue<Immediate, SymbolicValue>>()
   for entry in con-env do :
      if lookup(env, key(entry)) == false :
         match(lookup(alt-env, key(entry))) :
            (sv:SymbolicValue) :
               if eqv?(sv, value(entry)) : add(env, entry)
               else : add(env, key(entry) => WhenValue(pred, value(entry), sv))
            (f:False) : add(env, entry)
   for entry in alt-env do :
      if lookup(env, key(entry)) == false :
         add(env, entry)
   to-list(env)      

defn simplify-env (env: List<KeyValue<Immediate,SymbolicValue>>) :
   val seen = Vector<Immediate>()
   defn seen? (i:Immediate) :
      find(eqv?{i, _}, seen) != false
      
   to-list $
   for entry in env filter :
      if not seen?(key(entry)) :
         add(seen, key(entry))
         true

defn expand-whens (c:Command,
                   modules: List<KeyValue<Symbol, BundleType>>,
                   env:List<KeyValue<Immediate,SymbolicValue>>) :                   
   val cs = Vector<Command>()
   defn eval (c:Command, env:List<KeyValue<Immediate,SymbolicValue>>) ->
              List<KeyValue<Immediate,SymbolicValue>> :
      match(c) :
         (c:DefInt|DefSInt|DoPrim) :
            add(cs, c)
            env
         (c:DefWire) :
            add(cs, c)
            List(Ref(name(c), type(c)) => VoidValue(), env)
         (c:DefRegister) :
            add(cs, c)
            val ref = Ref(name(c), type(c))
            List(ref => ImmediateValue(ref), env)
         (c:DefInstance) :
            add(cs, c)
            val port-type = lookup!(modules, module(c))
            val ports* = 
               for p in ports(port-type) filter :
                  direction(p) == INPUT
            to-list{concat(_, env)} $      
            for p in ports* stream :
               val ref = Field(Ref(name(c), port-type), name(p), type(p))
               ref => VoidValue()
         (c:DefMemory) :
            add(cs, c)
            env
         (c:DefAccessor) :
            add(cs, c)
            if direction(c) == INPUT :         
               List(Ref(name(c), UnknownType()) => VoidValue(), env)
            else :
               env
         (c:Conditionally) :
            val con-env = eval(conseq(c), env)
            val alt-env = eval(alt(c), env)
            merge-env(pred(c), con-env, alt-env)
         (c:Begin) :
            var current-env:List<KeyValue<Immediate,SymbolicValue>> = env
            for c in body(c) do :
               current-env = eval(c, current-env)
            current-env
         (c:Connect) :
            List(loc(c) => ImmediateValue(exp(c)), env)
         (c:EmptyCommand) :
            env

   defn convert-symbolic (sv:SymbolicValue) :
      match(sv) :
         (sv:VoidValue) :
            throw $ PassException $ string-join $
            ["Uninitialized Connection."]
         (sv:ImmediateValue) :
            imm(sv)
         (sv:WhenValue) :
            val name = gensym()
            add{cs, _} $
            Select(name, pred(sv),
                   list(convert-symbolic(alt(sv)),
                        convert-symbolic(conseq(sv))))
            Ref(name, UnknownType())       
         
   val env* = simplify-env(eval(c, env))
   for entry in env* do :
      add(cs, Connect(key(entry), convert-symbolic(value(entry))))

   switch {length(cs) == _} :
      0 : EmptyCommand()
      1 : cs[0]
      else : Begin(to-list(cs))

defn expand-whens (m:Module,
                   modules: List<KeyValue<Symbol, BundleType>>) :
   
   val env = let :
      val in-ports = filter({direction(_) == OUTPUT}, ports(m))
      to-list $
      for p in in-ports stream :
         val ref = Field(Ref('this, UnknownType()), name(p), type(p))
         ref => VoidValue()
   val body* = expand-whens(body(m), modules, env)
   Module(name(m), ports(m), body*)

defn expand-whens (c:Circuit) :
   val module-ports =
      for m in modules(c) map :
         name(m) => BundleType(ports(m))
   val modules* =
      for m in modules(c) map :
         expand-whens(m, module-ports)
   Circuit(modules*, main(c))         

;============= DRIVER ======================================
public defn run-passes (c: Circuit) :
  var c*:Circuit = c
  check-duplicates(c*)
  c* = infer-types(c*)
  c* = expand-vecs(c*)
  c* = infer-accessor-dirs(c*)
  c* = expand-whens(c)
  c*
