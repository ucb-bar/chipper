defpackage chipper.passes:
  import core
  import verse
  import chipper.ir

;============== EXCEPTIONS =================================
defclass PassException <: Exception
defn PassException (msg:String) :
  new PassException :
    defmethod print (o:OutputStream, this) :
      print(o, msg)


;============ CHECK IF NAMES ARE UNIQUE ====================
defn check-duplicate-symbols (names: Streamable<Symbol>, msg: String) :
  val dict = HashTable<Symbol, True>(symbol-hash)
  for name in names do:
    if key?(dict, name):
      throw $ PassException $ string-join $
      [msg ": " name]
    else:
      dict[name] = true

defn check-duplicates (t: Type) :
  match(t) :
    (t:BundleType) :
      val names = map(name, ports(t))
      check-duplicate-symbols{names, string-join(_)} $
        ["Duplicate port name in bundle "]
      do(check-duplicates{type(_)}, ports(t))
    (t) : false

defn check-duplicates (c: Command) :
  match(c) :
    (c:DefWire) : check-duplicates(type(c))
    (c:DefRegister) : check-duplicates(type(c))
    (c:DefMemory) : check-duplicates(type(c))
    (c:DefVector) : check-duplicates(type(c))
    (c) : do(check-duplicates, children(c))  

defn defined-names (c: Command) :
  generate<Symbol> :
    loop(c) where :
      defn loop (c:Command) :
        match(c) :
          (c:Command&HasName) : yield(name(c))
          (c) : do(loop, children(c))

defn check-duplicates (m: Module):
  ;Check all duplicate names in all types in all ports and body
  do(check-duplicates{type(_)}, ports(m))
  check-duplicates(body(m))

  ;Check all names defined in module
  val names = concat(stream(name, ports(m)),
                     defined-names(body(m)))
  check-duplicate-symbols{names, string-join(_)} $
    ["Duplicate definition name in module " name(m)]

defn check-duplicates (c: Circuit) :
  ;Check all duplicate names in all modules
  do(check-duplicates, modules(c))

  ;Check all defined modules
  val names = stream(name, modules(c))
  check-duplicate-symbols(names, "Duplicate module name")



;============= INFER TYPES FOR ALL IMMEDIATES ==============
defn lookup-port (ports: Streamable<Port>, port-name: Symbol) :
  for port in ports find :
    name(port) == port-name

defn lookup-port! (ports: Streamable<Port>, port-name: Symbol) :
  match(lookup-port(ports, port-name)) :
    (p:Port) : p
    (p:False) :
      error $ string-join $
        ["No port found with name: " port-name "."]           

defn infer (i: Immediate, e: List<KeyValue<Symbol, Type>>) -> Immediate :
  match(i) :
    (r:Ref) :
      val type = lookup!(e, name(r))
      Ref(name(r), type)
    (f:Field) :
      val imm* = infer(imm(f), e)
      val type = match(type(imm*)) :
                   (t:BundleType) :
                     match(lookup-port(ports(t), name(f))) :
                       (p:Port) : type(p)
                       (p) : type(f)
                   (t) : type(f)
      Field(imm*, name(f), type)             

defn infer (p:PrimOp, arg-types: List<Type>) -> Type :
  IntType(UnknownWidth()) 

defn infer (c:Command, e: List<KeyValue<Symbol,Type>>) -> [Command, List<KeyValue<Symbol,Type>>] :
  defn push-e (name: Symbol, t: Type) : List(name => t, e)
  match(c) :
    (c:DefInt|DefSInt) :
      [c, push-e(name(c), IntType(UnknownWidth()))]
    (c:DefWire) :
      val value* = infer(value(c) as Immediate, e) when value(c) != false
      [DefWire(name(c), type(c), value*), push-e(name(c), type(c))]
    (c:DefRegister) :
      val value* = infer(value(c) as Immediate, e) when value(c) != false
      val type* = BundleType $ to-list $ [
                    Port('data, OUTPUT, type(c))
                    Port('init, INPUT, type(c))]
      [DefRegister(name(c), type(c), value*), push-e(name(c), type*)]
    (c:DefMemory) :
      [DefMemory(name(c), type(c), size(c)), push-e(name(c), type(c))]
    (c:DefVector) :
      val args* = map({infer(_, e)}, args(c))
      [DefVector(name(c), type(c), args*), push-e(name(c), type(c))]
    (c:DefAccessor) :
      val type = lookup!(e, source(c))
      val index* = infer(index(c), e)
      [DefAccessor(name(c), source(c), direction(c), index*), push-e(name(c), type)]
    (c:DefInstance) :
      val type = lookup!(e, module(c))
      [c, push-e(name(c), type)]
    (c:Conditionally) :
      val pred* = infer(pred(c), e)
      val [con*, con-e] = infer(conseq(c), e)
      val [alt*, alt-e] = infer(alt(c), e)
      [Conditionally(pred*, con*, alt*), e]
    (c:Begin) :        
      var current-e: List<KeyValue<Symbol,Type>> = e
      val body* = for c in body(c) map :
        val [c*, e] = infer(c, current-e)
        current-e = e
        c*
      [Begin(body*), current-e]   
    (c:Connect) :
      [Connect(infer(loc(c), e), infer(exp(c), e)), e]
    (c:DoPrim) :
      val args* = map(infer{_, e}, args(c))
      val type* = infer(op(c), map(type, args*))
      [DoPrim(name(c), op(c), args*), push-e(name(c), type*)]
    (c:Select) :
      val idx* = infer(idx(c), e)      
      val args* = map(infer{_, e}, args(c))
      val type* = type(args(c)[0])
      [Select(name(c), idx*, args*), push-e(name(c), type*)]        
    (c:SelectivelyConnect) :
      val idx* = infer(idx(c), e)
      val locs* = map(infer{_, e}, locs(c))
      val exp* = infer(exp(c), e)
      [SelectivelyConnect(idx*, locs*, exp*), e]
    (c:EmptyCommand) : [c, e]          

defn infer (m: Module, e: List<KeyValue<Symbol,Type>>) -> Module :
  val port-type = let :
    val type = lookup!(e, name(m)) as BundleType
    BundleType $ map(flip, ports(type))
  val m-env = List('this => port-type, e)
  val [body*, env*] = infer(body(m), m-env)
  Module(name(m), ports(m), body*)

defn infer-types (c: Circuit) -> Circuit:
  val env =
    for m in modules(c) map :
      name(m) => BundleType $
                   List(Port('reset, INPUT, IntType(IntWidth(1))),
                        ports(m))
  val modules* = map(infer{_, env}, modules(c))                      
  Circuit(modules*, main(c))  

;============= DRIVER ======================================
public defn run-passes (c: Circuit) :
   check-duplicates(c)
   infer-types(c)
