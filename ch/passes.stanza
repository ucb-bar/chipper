defpackage chipper.passes:
  import core
  import verse
  import chipper.ir

;============== EXCEPTIONS =================================
defclass PassException <: Exception
defn PassException (msg:String) :
  new PassException :
    defmethod print (o:OutputStream, this) :
      print(o, msg)

;================ UTILITIES ================================
defn lookup<?T> (e: Streamable<KeyValue<Immediate,?T>>, i:Immediate) :
   for entry in e search :
      if eqv?(key(entry), i) :
         value(entry)

defn* root-ref (i:Immediate) :
   match(i) :
      (f:Field) : root-ref(imm(f))
      (r:Ref) : r

defn replace-root (i:Immediate, root:Immediate) :
   match(i) :
      (r:Ref) : root
      (f:Field) :
         Field{_, name(f), direction(f), type(f)} $
         replace-root(imm(f), root)

defn replace-root (i:Immediate, old-root:Immediate, new-root:Immediate) :
   match(i, old-root) :
      (i:Field, r:Field) :
         if eqv?(i, r) : new-root
         else :
            val imm* = replace-root(imm(i), r, new-root)
            Field(imm*, name(i))
      (i:Ref, r:Ref) :
         if eqv?(i, r) : new-root
         else : i
      (i, r) :
         i

;============ CHECK IF NAMES ARE UNIQUE ====================
defn check-duplicate-symbols (names: Streamable<Symbol>, msg: String) :
  val dict = HashTable<Symbol, True>(symbol-hash)
  for name in names do:
    if key?(dict, name):
      throw $ PassException $ string-join $
      [msg ": " name]
    else:
      dict[name] = true

defn check-duplicates (t: Type) :
  match(t) :
    (t:BundleType) :
      val names = map(name, ports(t))
      check-duplicate-symbols{names, string-join(_)} $
        ["Duplicate port name in bundle "]
      do(check-duplicates{type(_)}, ports(t))
    (t) : false

defn check-duplicates (c: Command) :
  match(c) :
    (c:DefWire) : check-duplicates(type(c))
    (c:DefRegister) : check-duplicates(type(c))
    (c:DefMemory) : check-duplicates(type(c))
    (c:DefVector) : check-duplicates(type(c))
    (c) : do(check-duplicates, children(c))  

defn defined-names (c: Command) :
  generate<Symbol> :
    loop(c) where :
      defn loop (c:Command) :
        match(c) :
          (c:Command&HasName) : yield(name(c))
          (c) : do(loop, children(c))

defn check-duplicates (m: Module):
  ;Check all duplicate names in all types in all ports and body
  do(check-duplicates{type(_)}, ports(m))
  check-duplicates(body(m))

  ;Check all names defined in module
  val names = concat(stream(name, ports(m)),
                     defined-names(body(m)))
  check-duplicate-symbols{names, string-join(_)} $
    ["Duplicate definition name in module " name(m)]

defn check-duplicates (c: Circuit) :
  ;Check all duplicate names in all modules
  do(check-duplicates, modules(c))

  ;Check all defined modules
  val names = stream(name, modules(c))
  check-duplicate-symbols(names, "Duplicate module name")


;=============== MAKE RESET EXPLICIT =======================
defn make-explicit-reset (c: Command) -> Command :
   match(c) :
      (c:DefInstance) :
         val c2 = Connect(Field(Ref(name(c)), 'reset),
                          Field(Ref('this), 'reset))
         Begin(list(c, c2))
      (c) :
         map(make-explicit-reset{_ as Command}, c)

defn make-explicit-reset (m: Module) :
   val reset = Port('reset, INPUT, IntType(IntWidth(1)))
   Module(name(m),
          List(reset, ports(m)),
          make-explicit-reset(body(m)))

defn make-explicit-reset (c: Circuit) :
   val modules* = map(make-explicit-reset, modules(c))
   Circuit(modules*, main(c))


;======= MAKE EXPLICIT REGISTER INITIALIZATION =============
defn reg-inits (e: List<KeyValue<Immediate,Immediate>>) :
   if empty?(e) :
      EmptyCommand()
   else :
      val connections = Begin $ to-list $
         for entry in e map :
            Connect(key(entry), value(entry))
      Conditionally(
         Field(Ref('this), 'reset),
         connections,
         EmptyCommand())
            
;e is a mapping of (register => init wire)
defn initialize-registers (c: Command
                           e: List<KeyValue<Immediate,Immediate>>) ->
                           [Command, List<KeyValue<Immediate,Immediate>>] :

   defn replace-reg-ports (i:Immediate) :
      match(lookup(e, root-ref(i))) :
         (wire:Immediate) :
            val reg = root-ref(i)            
            replace-root{_, Field(reg, 'data), reg} $
               replace-root(i, Field(reg, 'init), wire)
         (f:False) :
            i
            
   match(c) :
      (c:DefRegister) :
         val reg = Ref(name(c))
         val init = Ref $ gensym $ string-join $ [name(c) "-init"]
         val c* = Begin $ to-list $ [
            c,
            DefWire(name(init), type(c))
            Connect(init, reg)]
         [c*, list(reg => init)]
      (c:Conditionally) :
         val pred* = replace-reg-ports(pred(c))
         val [conseq* con-e] = initialize-registers(conseq(c), e)
         val [alt* alt-e] = initialize-registers(alt(c), e)
         val c* = 
            Conditionally(
               pred*
               Begin(list(conseq*, reg-inits(con-e)))
               Begin(list(alt*, reg-inits(alt-e))))
         [c*, List()]      
      (c:Begin) :
         var current-e: List<KeyValue<Immediate,Immediate>> = e
         val defined = Vector<KeyValue<Immediate,Immediate>>()
         val body* = 
            for c in body(c) map :
               val [c* e*] = initialize-registers(c, current-e)
               current-e = append(e*, current-e)
               do(add{defined, _}, e*)
               c*
         [Begin(body*), to-list(defined)]
      (c) :
         [map(replace-reg-ports, c), List()]         
         
defn initialize-registers (m:Module) :
   val body* = let :
      val [body* regs] = initialize-registers(body(m), List())
      Begin(list(body*, reg-inits(regs)))
   Module(name(m), ports(m), body*)

defn initialize-registers (c:Circuit) :
   val modules* = map(initialize-registers, modules(c))
   Circuit(modules*, main(c))


;============= INFER TYPES FOR ALL IMMEDIATES ==============
defn lookup-port (ports: Streamable<Port>, port-name: Symbol) :
   for port in ports find :
      name(port) == port-name

defn lookup-port! (ports: Streamable<Port>, port-name: Symbol) :
  match(lookup-port(ports, port-name)) :
    (p:Port) : p
    (p:False) :
      error $ string-join $
        ["No port found with name: " port-name "."]           

defn lookup-ref (e: Streamable<Ref>, n:Symbol) :
   for entry in e find :
      name(entry) == n  

defn lookup-ref! (e: Streamable<Ref>, n:Symbol) :
   match(lookup-ref(e, n)) :
      (r:Ref) : r
      (r:False) : error $ string-join $
                  ["No ref exists with name: " n]                  

defn infer (i: Immediate, e: List<Ref>) -> Immediate :
  match(i) :
    (r:Ref) :
       lookup-ref!(e, name(r))
    (f:Field) :
       val imm* = infer(imm(f), e)
       val [port-type, port-dir] =
          match(type(imm*)) :
             (t:BundleType) :
                match(lookup-port(ports(t), name(f))) :
                   (p:Port) : [type(p), direction(p)]
                   (p) : [type(f), UNKNOWN-DIR]
             (t) :
                [type(f), UNKNOWN-DIR]
       Field(imm*, name(f), direction(imm*) * port-dir, port-type)             

defn infer (p:PrimOp, arg-types: List<Type>) -> Type :
  IntType(UnknownWidth()) 

defn infer (c:Command, in-e: List<Ref>, out-e: List<Ref>) -> [Command, List<Ref>, List<Ref>] :
   match(c) :
      (c:DefInt|DefSInt) :
         val ref = Ref(name(c), OUTPUT, IntType(UnknownWidth()))
         [c, List(ref, in-e), List(ref, out-e)]
      (c:DefWire) :
         val in-ref = Ref(name(c), INPUT, type(c))
         val out-ref = Ref(name(c), OUTPUT, type(c))
         [c, List(in-ref, in-e), List(out-ref, out-e)]
      (c:DefRegister) :
         val in-ref = Ref(name(c), INPUT, type(c))
         val out-ref = Ref(name(c), OUTPUT, type(c))
         [c, List(in-ref, in-e), List(out-ref, out-e)]
      (c:DefMemory) :
         val in-ref = Ref(name(c), INPUT, type(c))
         val out-ref = Ref(name(c), OUTPUT, type(c))
         [c, List(in-ref, in-e), List(out-ref, out-e)]
      (c:DefVector) :
         val args* = map({infer(_, out-e)}, args(c))
         val in-ref = Ref(name(c), INPUT, type(c))
         val out-ref = Ref(name(c), OUTPUT, type(c))
         [DefVector(name(c), type(c), args*), List(in-ref, in-e), List(out-ref, out-e)]
      (c:DefAccessor) :
         val source* = let :
            val s = infer(source(c), out-e) as Ref
            Ref(name(s), UNKNOWN-DIR, type(s))
         val index* = infer(index(c), out-e)   
         val in-ref = Ref(name(c), INPUT, type(source*))
         val out-ref = Ref(name(c), OUTPUT, type(source*))
         [DefAccessor(name(c), source*, UNKNOWN-DIR, index*), List(in-ref, in-e), List(out-ref, out-e)]
      (c:DefInstance) :
         val module* = infer(module(c), out-e) as Ref
         val ref = Ref(name(c), direction(module*), type(module*))
         [DefInstance(name(c), module*), List(ref, in-e), List(ref, out-e)]
      (c:Conditionally) :
         val pred* = infer(pred(c), out-e)
         val [con*, con-in-e, con-out-e] = infer(conseq(c), in-e, out-e)
         val [alt*, alt-in-e, alt-out-e] = infer(alt(c), in-e, out-e)
         [Conditionally(pred*, con*, alt*), in-e, out-e]
      (c:Begin) :        
         var current-in-e: List<Ref> = in-e
         var current-out-e: List<Ref> = out-e
         val body* = for c in body(c) map :
            val [c*, in-e, out-e] = infer(c, current-in-e, current-out-e)
            current-in-e = in-e
            current-out-e = out-e
            c*
         [Begin(body*), current-in-e, current-out-e]
      (c:Connect) :
         val loc* = infer(loc(c), in-e)
         val exp* = infer(exp(c), out-e)
         [Connect(loc*, exp*), in-e, out-e]
      (c:DoPrim) :
         val args* = map(infer{_, out-e}, args(c))
         val type* = infer(op(c), map(type, args*))
         val ref = Ref(name(c), OUTPUT, type*)
         [DoPrim(name(c), op(c), args*), List(ref, in-e), List(ref, out-e)]
      (c:ConnectMany) :
         val idx* = infer(idx(c), out-e)
         val loc* = infer(loc(c), in-e)
         val exps* = map(infer{_, out-e}, exps(c))
         [ConnectMany(idx*, loc*, exps*), in-e, out-e]
      (c:ManyConnect) :
         val idx* = infer(idx(c), out-e)
         val locs* = map(infer{_, in-e}, locs(c))
         val exp* = infer(exp(c), out-e)
         [ManyConnect(idx*, locs*, exp*), in-e, out-e]
      (c:EmptyCommand) : [c, in-e, out-e]          

defn infer (m: Module, e: List<Ref>) -> Module :
   val ref = lookup-ref!(e, name(m))
   val m-env = List(Ref('this, INPUT, type(ref)), e)
   val [body*, in-env*, out-env*] = infer(body(m), m-env, m-env)
   Module(name(m), ports(m), body*)

defn infer-types (c: Circuit) -> Circuit :
   val env =
      for m in modules(c) map :
         Ref(name(m), OUTPUT, BundleType(ports(m)))
   val modules* = map(infer{_, env}, modules(c))                      
   Circuit(modules*, main(c))  

;========= INFER DIRECTIONS OF ACCESSORS ===================
defn find-accessor-uses (c:Command) :
   to-list $ generate<Ref> :
      val accessors = Vector<Symbol>()
      defn find-use (imm:Immediate) :
         val root = root-ref(imm)
         yield(root) when contains?(accessors, name(root))        
         imm
      loop(c) where :  
         defn loop (c:Command) :
            match(map(find-use, c)) :
               (c:DefAccessor) : add(accessors, name(c))
               (c) : do(loop, children(c))

defn fold-accessor-uses (uses: List<Ref>) :
   val table = HashTable<Symbol,Ref>(symbol-hash)
   for use in uses do :
      match(get?(table, name(use), false)) :
         (r:Ref) :
            if direction(r) != direction(use) :
               throw $ PassException $ string-join $
               ["Accessor " name(use) " is used both as an INPUT and an OUTPUT."]          
         (f:False) :
            table[name(use)] = use
   to-list(stream(value, table))

defn fill-accessor-dirs (c:Command, uses:List<Ref>) -> Command :
   match(c) :
      (c:DefAccessor) :
         val dir =
            match(lookup-ref(uses, name(c))) :
               (r:Ref) : direction(r)
               (d:False) : throw $ PassException $ string-join $
                           ["Accessor " name(c) " is never used. Unable to infer direction."]
         DefAccessor(name(c), source(c), dir, index(c))
      (c:Command) :
         map(fill-accessor-dirs{_, uses}, c)

defn infer-accessor-dirs (c:Circuit) :
   val modules* =
      for m in modules(c) map :
         val uses = fold-accessor-uses(find-accessor-uses(body(m)))
         val body* = fill-accessor-dirs(body(m), uses)
         Module(name(m), ports(m), body*)
   Circuit(modules*, main(c))


;============== EXPAND VECS ================================
defn lookup-vector (vecs: Streamable<DefVector>, n:Symbol) :
   for v in vecs find :
      name(v) == n
      
defn expand-vecs (c: Command) :
   val vecs = Vector<DefVector>()
   defn expand (c:Command) :
      match(c) :
         (c:DefAccessor) :
            match(lookup-vector(vecs, name(source(c)))) :
               (vec:DefVector) :
                  switch {direction(c) == _} :
                     OUTPUT :
                        Begin $ to-list $ [
                           DefWire(name(c), type(source(c)))
                           ConnectMany(index(c), Ref(name(c)), args(vec))]
                     INPUT :
                        Begin $ to-list $ [
                           DefWire(name(c), type(source(c)))
                           ManyConnect(index(c), args(vec), Ref(name(c)))]
               (vec:False) :
                  c
         (c:DefVector) :
            add(vecs, c)
            EmptyCommand()
         (c) :
            map(expand, c)
   expand(c)         

defn expand-vecs (c:Circuit) :
   val modules* =
      for m in modules(c) map :
         Module(name(m), ports(m), expand-vecs(body(m)))
   Circuit(modules*, main(c))      



;=============== BUNDLE FLATTENING =========================
defn flatten-ports (p:Port) -> List<Port> :
   match(type(p)) :
      (t:BundleType) :
         val ports = map-append(flatten-ports, ports(t))
         for port in ports map :
            val name* = symbol-join([name(p) "/" name(port)])
            Port(name*, direction(p) * direction(port), type(port))             
      (t:Type) :
         list(p)

defn flatten-type (t:Type) -> Type :
   match(t) :
      (t:BundleType) :
         BundleType $
         map-append(flatten-ports, ports(t))
      (t:Type) :
         t         

defn flatten-imm (i:Immediate) -> Immediate :
   match(i) :
      (r:Ref) : Ref(name(r), direction(r), flatten-type(type(r)))
      (f:Field) : Field(flatten-imm(imm(f)), name(f), direction(f), flatten-type(type(f)))
      
defn flatten-command (c: Command) -> Command :
   match(map(flatten-imm, c)) :
      (c:DefWire) : DefWire(name(c), flatten-type(type(c)))
      (c:DefRegister) : DefRegister(name(c), flatten-type(type(c)))
      (c:DefMemory) : DefMemory(name(c), flatten-type(type(c)), size(c))
      (c) : map(flatten-command, c)

defn flatten-bundles (m: Module) :
   val ports* = map-append(flatten-ports, ports(m))
   val body* = flatten-command(body(m))
   Module(name(m), ports*, body*)
   
defn flatten-bundles (c: Circuit) :
   Circuit(map(flatten-bundles, modules(c)), main(c))



;================== BUNDLE EXPANSION =======================
defn expand-imm-bundles (i:Immediate) -> List<Immediate> :
   val cname = collapsed-name(i) where :
      defn collapsed-name (i:Immediate) :
         match(i) :
            (i:Ref) : name(i)
            (i:Field) : symbol-join $ [collapsed-name(imm(i)) "/" name(i)]      
   match(type(i)) :
      (t:BundleType) :
         for port in ports(t) map :
            val name = symbol-join $ [cname "/" name(port)]
            Ref(name, direction(i) * direction(port), type(port))
      (t) :
         list(i)

defn expand-mem-bundles (m: DefMemory) -> Command :
   match(type(m)) :
      (t:BundleType) :
         Begin $
         for p in ports(t) map :
            val name = symbol-join $ [name(m) "/" name(p)]
            DefMemory(name, type(p), size(m))
      (t) :
         m

defn expand-accessor-bundles (a: DefAccessor) -> Command :
   match(type(source(a))) :
      (t:BundleType) :
         val sources = expand-imm-bundles(source(a))
         Begin $
         for (p in ports(t), s in sources) map :
            val name = symbol-join $ [name(a) "/" name(p)]
            DefAccessor(name, s as Ref, direction(a), index(a))
      (t) :
         a

defn expand-connect-many (c:ConnectMany) -> Command :
   val locs = expand-imm-bundles(loc(c))
   val exps-list = transpose(map(expand-imm-bundles, exps(c)))
   Begin $
   for (loc in locs, exps in exps-list) map :
      switch {direction(loc) == _} :
         INPUT : ConnectMany(idx(c), loc, exps)
         OUTPUT : ManyConnect(idx(c), exps, loc)

defn expand-many-connect (c:ManyConnect) -> Command :
   val locs-list = transpose(map(expand-imm-bundles, locs(c)))
   val exps = expand-imm-bundles(exp(c))
   Begin $
   for (locs in locs-list, exp in exps) map :
      switch {direction(exp) == _} :
         OUTPUT : ManyConnect(idx(c), locs, exp)
         INPUT : ConnectMany(idx(c), exp, locs)

defn expand-connect (c:Connect) -> Command :
   val locs = expand-imm-bundles(loc(c))
   val exps = expand-imm-bundles(exp(c))
   Begin $
   for (loc in locs, exp in exps) map :
      switch {direction(loc) == _} :
         INPUT : Connect(loc, exp)
         OUTPUT : Connect(exp, loc)

defn expand-wires (c:DefWire) -> Command :
   match(type(c)) :
      (t:BundleType) :
         Begin $
         for p in ports(t) map :
            val name = symbol-join $ [name(c) "/" name(p)]
            DefWire(name, type(p))
      (t) :
         c

defn expand-registers (c:DefRegister) -> Command :
   match(type(c)) :
      (t:BundleType) :
         Begin $
         for p in ports(t) map :
            val name = symbol-join $ [name(c) "/" name(p)]
            DefRegister(name, type(p))
      (t) :
         c

defn expand-instance (c:DefInstance) -> Command :
   Begin{to-list(_)} $
   generate<Command> :
      yield(c)
      val module-type = type(module(c)) as BundleType
      for p in ports(module-type) do :
         val wire-name = symbol-join $ [name(c) "/" name(p)]
         yield(DefWire(wire-name, type(p)))
         switch {direction(p) == _} :
            INPUT : yield(Connect(Field(Ref(name(c)), name(p)), Ref(wire-name)))
            OUTPUT : yield(Connect(Ref(wire-name), Field(Ref(name(c)), name(p))))

defn expand-bundles (c:Command) -> Command :
   match(c) :
      (c:DefWire) : expand-wires(c)
      (c:DefRegister) : expand-registers(c)
      (c:DefInstance) : expand-instance(c)
      (c:DefMemory) : expand-mem-bundles(c)
      (c:DefAccessor) : expand-accessor-bundles(c)
      (c:ConnectMany) : expand-connect-many(c)
      (c:ManyConnect) : expand-many-connect(c)
      (c:Connect) : expand-connect(c)
      (c) : map(expand-bundles, c)

defn expand-circuit-bundles (c:Circuit) :
   val c* = flatten-bundles(c)
   val modules* =
      for m in modules(c*) map :
         Module(name(m), ports(m), expand-bundles(body(m)))
   Circuit(modules*, main(c))      


;================ CLEANUP COMMANDS =========================
defn cleanup-command (c:Command) :
   match(c) :
      (c:Begin) :         
         val cs = to-list $ generate<Command> :
            loop(c) where :
               defn loop (c:Command) :
                  match(c) :
                     (c:Begin) : do(loop, body(c))
                     (c:EmptyCommand) : false
                     (c) : yield(cleanup-command(c))
         switch {length(cs) == _} :
            0 : EmptyCommand()
            1 : head(cs)
            else : Begin(cs)
      (c) : map(cleanup-command, c)

defn cleanup-circuit (c:Circuit) :
   val modules* =
      for m in modules(c) map :
         Module(name(m), ports(m), cleanup-command(body(m)))
   Circuit(modules*, main(c))                              
                     

;================ EXPAND WHENS =============================
definterface SymbolicValue 
defstruct ImmediateValue <: SymbolicValue :
  imm: Immediate
defstruct WhenValue <: SymbolicValue :
  pred: Immediate
  conseq: SymbolicValue
  alt: SymbolicValue
defstruct VoidValue <: SymbolicValue

defn eqv? (v1:SymbolicValue, v2:SymbolicValue) :
   match(v1, v2) :
      (v1:ImmediateValue, v2:ImmediateValue) :
         eqv?(imm(v1), imm(v2))
      (v1:WhenValue, v2:WhenValue) :
         eqv?(pred(v1), pred(v2)) and
         eqv?(conseq(v1), conseq(v2)) and
         eqv?(alt(v1), alt(v2))
      (v1:VoidValue, v2:VoidValue) : true
      (v1, v2) : false

defn merge-env (pred:Immediate,
                con-env: List<KeyValue<Immediate,SymbolicValue>>,
                alt-env: List<KeyValue<Immediate,SymbolicValue>>) :         
   val env = Vector<KeyValue<Immediate, SymbolicValue>>()
   for entry in con-env do :
      if lookup(env, key(entry)) == false :
         match(lookup(alt-env, key(entry))) :
            (sv:SymbolicValue) :
               if eqv?(sv, value(entry)) : add(env, entry)
               else : add(env, key(entry) => WhenValue(pred, value(entry), sv))
            (f:False) : add(env, entry)
   for entry in alt-env do :
      if lookup(env, key(entry)) == false :
         add(env, entry)
   to-list(env)      

defn simplify-env (env: List<KeyValue<Immediate,SymbolicValue>>) :
   val seen = Vector<Immediate>()
   defn seen? (i:Immediate) :
      find(eqv?{i, _}, seen) != false
      
   to-list $
   for entry in env filter :
      if not seen?(key(entry)) :
         add(seen, key(entry))
         true

defn expand-whens (c:Command,
                   modules: List<KeyValue<Symbol, BundleType>>,
                   env:List<KeyValue<Immediate,SymbolicValue>>) :                   
   val cs = Vector<Command>()
   defn eval (c:Command, env:List<KeyValue<Immediate,SymbolicValue>>) ->
              List<KeyValue<Immediate,SymbolicValue>> :
      match(c) :
         (c:DefInt|DefSInt|DoPrim) :
            add(cs, c)
            env
         (c:DefWire) :
            add(cs, c)
            List(Ref(name(c), type(c)) => VoidValue(), env)
         (c:DefRegister) :
            add(cs, c)
            val ref = Ref(name(c), type(c))
            List(ref => ImmediateValue(ref), env)
         (c:DefInstance) :
            add(cs, c)
            val port-type = lookup!(modules, module(c))
            val ports* = 
               for p in ports(port-type) filter :
                  direction(p) == INPUT
            to-list{concat(_, env)} $      
            for p in ports* stream :
               val ref = Field(Ref(name(c), port-type), name(p), type(p))
               ref => VoidValue()
         (c:DefMemory) :
            add(cs, c)
            env
         (c:DefAccessor) :
            add(cs, c)
            if direction(c) == INPUT :         
               List(Ref(name(c), UnknownType()) => VoidValue(), env)
            else :
               env
         (c:Conditionally) :
            val con-env = eval(conseq(c), env)
            val alt-env = eval(alt(c), env)
            merge-env(pred(c), con-env, alt-env)
         (c:Begin) :
            var current-env:List<KeyValue<Immediate,SymbolicValue>> = env
            for c in body(c) do :
               current-env = eval(c, current-env)
            current-env
         (c:Connect) :
            List(loc(c) => ImmediateValue(exp(c)), env)
         (c:EmptyCommand) :
            env

   defn convert-symbolic (sv:SymbolicValue) :
      match(sv) :
         (sv:VoidValue) :
            throw $ PassException $ string-join $
            ["Uninitialized Connection."]
         (sv:ImmediateValue) :
            imm(sv)
         (sv:WhenValue) :
            val name = gensym()
            add{cs, _} $
            Select(name, pred(sv),
                   list(convert-symbolic(alt(sv)),
                        convert-symbolic(conseq(sv))))
            Ref(name, UnknownType())       
         
   val env* = simplify-env(eval(c, env))
   for entry in env* do :
      add(cs, Connect(key(entry), convert-symbolic(value(entry))))

   switch {length(cs) == _} :
      0 : EmptyCommand()
      1 : cs[0]
      else : Begin(to-list(cs))

defn expand-whens (m:Module,
                   modules: List<KeyValue<Symbol, BundleType>>) :
   
   val env = let :
      val in-ports = filter({direction(_) == OUTPUT}, ports(m))
      to-list $
      for p in in-ports stream :
         val ref = Field(Ref('this, UnknownType()), name(p), type(p))
         ref => VoidValue()
   val body* = expand-whens(body(m), modules, env)
   Module(name(m), ports(m), body*)

defn expand-whens (c:Circuit) :
   val module-ports =
      for m in modules(c) map :
         name(m) => BundleType(ports(m))
   val modules* =
      for m in modules(c) map :
         expand-whens(m, module-ports)
   Circuit(modules*, main(c))         

;============= DRIVER ======================================
public defn run-passes (c: Circuit) :
  var c*:Circuit = c
  check-duplicates(c*)
  c* = make-explicit-reset(c*)
  c* = initialize-registers(c*)
  c* = infer-types(c*)
  c* = infer-accessor-dirs(c*)
  c* = expand-vecs(c*)
  c* = infer-types(c*)
  c* = expand-circuit-bundles(c*)
  c* = cleanup-circuit(c*)
  






;  c* = expand-whens(c)
  c*
