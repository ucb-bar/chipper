defpackage mjolnir.construct :
   import core
   import verse
   import mjolnir.mj-ir   

;========== Namespaces =================
val MODULE-NAMES = HashTable<Symbol,True>(symbol-hash)
defn gen-module-name (name:Symbol) :
   if key?(MODULE-NAMES, name) : gensym(to-string(name))
   else :
      MODULE-NAMES[name] = true
      name

var SCOPE-NAMES: HashTable<Symbol,True> = HashTable<Symbol,True>(symbol-hash)
defn gen-scope-name (name:Symbol) :
   if key?(SCOPE-NAMES, name) : gensym(to-string(name))
   else :
      SCOPE-NAMES[name] = true
      name
defn in-new-scope<?T> (f: () -> ?T) :
   val prev-scope = SCOPE-NAMES
   dynamic-wind(
      fn () : SCOPE-NAMES = HashTable<Symbol,True>(symbol-hash)
      f
      fn (f) : SCOPE-NAMES = prev-scope)

;========== Command List ===============
val COMMAND-LIST = Vector<Command>()

defn push-command (c:Command) :
   add(COMMAND-LIST, c)
   
defn collect-commands (f: () -> ?) :
   val commands = Vector<Command>()
   val prev-commands = COMMAND-LIST
   dynamic-wind(
      fn () : COMMAND-LIST = commands
      f
      fn (f) : COMMAND-LIST = prev-commands)

   ;Group commands
   val n = length(commands)
   switch {n == _} :
      0 : EmptyCommand()
      1 : commands[0]
      else : Begin(to-list(commands))


;========== Module List ================
val MODULE-LIST = Vector<Module>()

public defn make-module (name:Symbol, ports: Streamable<Port>, f: () -> ?) :
   val name* = gen-module-name(name)
   val body = in-new-scope(collect-commands{f})
   add(MODULE-LIST, Module(name*, to-list(ports), body))
   name*

public defn make-instance (name:Symbol, module:Symbol) :
   val name* = gen-scope-name(name)
   push-command(DefInstance(name*, module))
   Ref(name*, UnknownType())

public definterface ModuleBuilder<T>
public defmulti handle<?T> (m:ModuleBuilder<?T>, name:Symbol) -> T

;========= Conditions ==================
public defn conditionally (pred: Handle, conseq: () -> ?, alt: () -> ?) :
   val conseq-body = collect-commands(conseq)
   val alt-body = collect-commands(alt)
   push-command(Conditionally(immediate(pred), conseq-body, alt-body))

;========== Circuit ====================
public defn make-circuit (f: () -> ?) :
   clear(MODULE-NAMES)
   clear(MODULE-LIST)
   clear(COMMAND-LIST)
   f()
   val top-module = module(last-command) where :
      val last-command = COMMAND-LIST[length(COMMAND-LIST) - 1] as DefInstance
   Circuit(to-list(MODULE-LIST), top-module)   

;=========== Wires =====================
public defn make-wire<?T> (name:Symbol, builder:MBuilder<?T>, value:Nil|Handle) -> T :
   push-command{DefWire(name, type(builder), _)} $
      match(value) :
         (v:Handle) : immediate(v)
         (v:Nil) : nil
   handle(builder, Ref(name))

;============ Registers ================
public defn make-register<?T> (name:Symbol, builder:MBuilder<?T>, value:Nil|Handle) -> T :
   push-command{DefRegister(name, type(builder), _)} $
      match(value) :
         (v:Handle) : immediate(v)
         (v:Nil) : nil
   handle(builder, Ref(name))      

;=========== Builders ==================
public definterface MBuilder<T>
public defmulti handle<?T> (b:MBuilder<?T>, ref:Immediate) -> T
public defmulti type (b:MBuilder) -> Type

;=========== Handles ===================
public definterface Handle
public defmulti immediate (h:Handle) -> Immediate

public defn connect-handles (h1:Handle, h2:Handle) :
   push-command(Connect(immediate(h1), immediate(h2)))

;========== Int Handles ================
public defclass IntT <: Handle

public defn connect (h1:IntT, h2:IntT) :
   connect-handles(h1, h2)

public defn IntT (width:Width) :
   new MBuilder<IntT> :
      defmethod handle (this, ref:Immediate) :
         new IntT :
            defmethod immediate (this) : ref
      defmethod type (this) :
         IntType(width)

public defn IntT (width:Int) :
   IntT(IntWidth(width))

public defn IntT () :
   IntT(UnknownWidth())

;=========== Int Operators =============
defn do-op (op:PrimOp, h1:IntT, h2:IntT) :
   val name = gen-scope-name('n)
   push-command(DoPrim(name, op, list(immediate(h1), immediate(h2))))
   handle(IntT(), Ref(name, UnknownType()))

public defn plus (h1:IntT, h2:IntT) : do-op(ADD-OP, h1, h2)
public defn minus (h1:IntT, h2:IntT) : do-op(MINUS-OP, h1, h2)
public defn times (h1:IntT, h2:IntT) : do-op(TIMES-OP, h1, h2)
public defn divide (h1:IntT, h2:IntT) : do-op(DIVIDE-OP, h1, h2)
public defn modulo (h1:IntT, h2:IntT) : do-op(MOD-OP, h1, h2)
public defn shift-left (h1:IntT, h2:IntT) : do-op(SHIFT-LEFT-OP, h1, h2)
public defn shift-right (h1:IntT, h2:IntT) : do-op(SHIFT-RIGHT-OP, h1, h2)
public defn bit-and (h1:IntT, h2:IntT) : do-op(BIT-AND-OP, h1, h2)
public defn bit-or (h1:IntT, h2:IntT) : do-op(BIT-OR-OP, h1, h2)
public defn bit-xor (h1:IntT, h2:IntT) : do-op(BIT-XOR-OP, h1, h2)
public defn bit-concat (h1:IntT, h2:IntT) : do-op(CONCAT-OP, h1, h2)
public defn less? (h1:IntT, h2:IntT) : do-op(LESS-OP, h1, h2)
public defn less-eq? (h1:IntT, h2:IntT) : do-op(LESS-EQ-OP, h1, h2)
public defn greater? (h1:IntT, h2:IntT) : do-op(GREATER-OP, h1, h2)
public defn greater-eq? (h1:IntT, h2:IntT) : do-op(GREATER-EQ-OP, h1, h2)
public defn bit-equal? (h1:IntT, h2:IntT) : do-op(EQUAL-OP, h1, h2)
public defn get (h1:IntT, h2:IntT) : do-op(BIT-SELECT-OP, h1, h2)
public defn get (h1:IntT, i:Int) : do-op(BIT-SELECT-OP, h1, MInt(i))

;========= Constructors ================
public defn MInt (value:Int) :
   val name = gen-scope-name('n)
   push-command(DefInt(name, value))
   handle(IntT(), Ref(name, UnknownType()))