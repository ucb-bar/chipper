include<"core/core.stanza">
include<"core/verse.stanza">
include("ch/ch-ir.stanza")
include("ch/ch-construct.stanza")
include("ch/passes.stanza")
include-syntax(chipper)

defpackage debug :
   import core
   import verse
   import chipper.ir
   import chipper.construct
   import chipper.passes

defbundle Decoupled<T> () :
   output data: T
   output valid: IntT(1)
   input ready: IntT(1)

defmodule Adder (w:Int) :
   input a: IntT(w)
   input b: IntT(w)
   output z: IntT(w + 1)
   z(this) := a(this) + b(this)

defmodule BigAdder (w:Int) :
   input a: IntT(w)
   input b: IntT(w)
   input c: IntT(w)
   input d: IntT(w)
   input e: IntT(w)
   input f: IntT(w)
   input g: IntT(w)
   input h: IntT(w)
   input en: IntT(1)
   output z: IntT(w + 2)   

   instance ab: Adder(w)
   a(ab) := a(this)
   b(ab) := b(this)

   instance cd: Adder(w)
   a(cd) := c(this)
   b(cd) := d(this)

   instance abcd: Adder(w + 1)
   a(abcd) := z(ab)
   b(abcd) := z(cd)

   z(this) := CInt(0)
   when en(this) :
      z(this) := z(abcd)

defmodule Top () :
   input a: IntT(10)
   output z: IntT(12)

   instance adder: BigAdder(10)
   a(adder) := a(this)
   b(adder) := a(this)
   c(adder) := a(this)
   d(adder) := a(this)
   en(adder) := CInt(1)
   z(this) := z(adder)

   ;== TESTING ==
   register r : Decoupled(IntT())
   data(r) := a(adder)
   z(this) := ready(r)
   data(init(r)) := b(adder)

   vec v : IntT() of [a(adder), b(adder), c(adder), d(adder)]
   v[0] := CInt(0)
   v[1] := CInt(1)
   v[2] := CInt(2)
   v[3] := CInt(3)
   v[CInt(0)] := CInt(42)

   v[CInt(4)] := CInt(42) + v[CInt(0)]

defmodule Test () :
   input a: IntT(1)
   input x: IntT(1)
   input y: IntT(1)
   output c: IntT(3)

   
   c(this) := CInt(0)
   wire d: IntT() = a(this)
   register r: IntT() = a(this)
   when x(this) :
      when y(this) :
         c(this) := CInt(42)         
   else :
      c(this) := CInt(2)
      d := CInt(42) + y(this)

defn main () :
   circuit c: Top()
   println(c)
   println("==== INFER ====")
   println(run-passes(c))

main()
