include<"core/core.stanza">
include<"core/verse.stanza">
include<"core/stringeater.stanza">
include<"compiler/lexer.stanza">
include("ch/ch-ir.stanza")
include("ch/ch-construct.stanza")
include("ch/passes.stanza")
include("ch/widthsolver.stanza")
include-syntax(chipper)

defpackage debug :
   import core
   import verse
   import chipper.ir
   import chipper.construct
   import chipper.passes

defbundle Decoupled<T> () :
   output data: T
   output valid: IntT(1)
   input ready: IntT(1)

defmodule Adder () :
   input a: IntT()
   input b: IntT()
   output z: IntT()
   z(this) := a(this) + b(this)

defmodule BigAdder (w:Int) :
   input a: IntT(w)
   input b: IntT(w)
   input c: IntT(w)
   input d: IntT(w)
   input e: IntT(w)
   input f: IntT(w)
   input g: IntT(w)
   input h: IntT(w)
   input en: IntT(1)
   output z: IntT(w + 2)   

   instance ab: Adder()
   a(ab) := a(this)
   b(ab) := b(this)

   instance cd: Adder()
   a(cd) := c(this)
   b(cd) := d(this)

   instance abcd: Adder()
   a(abcd) := z(ab)
   b(abcd) := z(cd)

   z(this) := CInt(0)
   when en(this) :
      z(this) := z(abcd)

defmodule Top () :
   input a: IntT(10)
   output z: IntT(12)

   instance adder: BigAdder(10)
   a(adder) := a(this)
   b(adder) := a(this)
   c(adder) := a(this)
   d(adder) := a(this)
   e(adder) := a(this)
   f(adder) := a(this)
   g(adder) := a(this)
   h(adder) := a(this)
   en(adder) := CInt(1)
   z(this) := z(adder)

defmodule Test () :
   input a: Decoupled(IntT(1))
   input b: Decoupled(IntT(1))
   input c: Decoupled(IntT(1))
   output z: Decoupled(IntT(1))

   data(a(this)) := CInt(0)

;   vec v: Decoupled(IntT(1)) of [a(this) b(this) c(this)]
;   v[CInt(0)] := v[CInt(1)]


defn main () :
   circuit c: Top()
   println(c)
   println("==== INFER ====")
   println(run-passes(c))

main()
